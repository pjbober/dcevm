# HG changeset patch
# Parent 5be37d3ef648d06850aa164d8b22ac7539559e80
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/ci/ciObjectFactory.cpp
--- a/src/share/vm/ci/ciObjectFactory.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/ci/ciObjectFactory.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -756,3 +756,27 @@
              _unloaded_instances->length(),
              _unloaded_klasses->length());
 }
+
+int ciObjectFactory::compare_cimetadata(ciMetadata** a, ciMetadata** b) {
+  Metadata* am = (*a)->constant_encoding();
+  Metadata* bm = (*b)->constant_encoding();
+  return ((am > bm) ? 1 : ((am == bm) ? 0 : -1));
+}
+
+// (DCEVM) Resoring the ciObject arrays after class redefinition
+void ciObjectFactory::resort_shared_ci_metadata() {
+  if (_shared_ci_metadata == NULL) return;
+  _shared_ci_metadata->sort(ciObjectFactory::compare_cimetadata);
+
+#ifdef ASSERT
+  if (CIObjectFactoryVerify) {
+    Metadata* last = NULL;
+    for (int j = 0; j< _shared_ci_metadata->length(); j++) {
+      Metadata* o = _shared_ci_metadata->at(j)->constant_encoding();
+      assert(last < o, "out of order");
+      last = o;
+    }
+  }
+#endif // ASSERT
+}
+
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/ci/ciObjectFactory.hpp
--- a/src/share/vm/ci/ciObjectFactory.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/ci/ciObjectFactory.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -90,6 +90,7 @@
 
   ciInstance* get_unloaded_instance(ciInstanceKlass* klass);
 
+  static int compare_cimetadata(ciMetadata** a, ciMetadata** b);
 public:
   static bool is_initialized() { return _initialized; }
 
@@ -145,6 +146,8 @@
 
   void print_contents();
   void print();
+
+  static void resort_shared_ci_metadata();
 };
 
 #endif // SHARE_VM_CI_CIOBJECTFACTORY_HPP
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/classFileParser.cpp
--- a/src/share/vm/classfile/classFileParser.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/classFileParser.cpp	Fri Dec 15 05:23:25 2017 -0500

@@ -105,6 +105,8 @@

 #define JAVA_9_VERSION                    53

+#define POST_PROCESSING_SKIP              1
+#define POST_PROCESSING_DO                0
 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
   assert((bad_constant == 19 || bad_constant == 20) && _major_version >= JAVA_9_VERSION,
          "Unexpected bad constant pool entry");
@@ -822,6 +824,7 @@
 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,
                                        const int itfs_len,
                                        ConstantPool* const cp,
+                                       bool pick_newest,
                                        bool* const has_nonstatic_concrete_methods,
                                        TRAPS) {
   assert(stream != NULL, "invariant");
@@ -843,7 +846,11 @@
         "Interface name has bad constant pool index %u in class file %s",
         interface_index, CHECK);
       if (cp->tag_at(interface_index).is_klass()) {
-        interf = KlassHandle(THREAD, cp->resolved_klass_at(interface_index));
+                Klass* resolved_klass = _cp->resolved_klass_at(interface_index);
+                if (pick_newest) {
+                    resolved_klass = resolved_klass->newest_version();
+                }
+                interf = KlassHandle(THREAD, resolved_klass);
       } else {
         Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);

@@ -853,13 +860,16 @@
                            "Bad interface name in class file %s", CHECK);

         // Call resolve_super so classcircularity is checked
-        const Klass* const k =
+        const Klass* k =
           SystemDictionary::resolve_super_or_fail(_class_name,
                                                   unresolved_klass,
                                                   _loader_data->class_loader(),
                                                   _protection_domain,
                                                   false,
                                                   CHECK);
+        if (pick_newest) {
+                    k = k->newest_version();
+                }
         interf = KlassHandle(THREAD, k);
       }

@@ -3539,7 +3549,7 @@
 }

 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
-                                                        const int super_class_index,
+                                                        const int super_class_index, bool pick_newest,
                                                         const bool need_verify,
                                                         TRAPS) {
   assert(cp != NULL, "invariant");
@@ -3559,7 +3569,11 @@
     // However, make sure it is not an array type.
     bool is_array = false;
     if (cp->tag_at(super_class_index).is_klass()) {
-      super_klass = InstanceKlass::cast(cp->resolved_klass_at(super_class_index));
+      Klass* resolved_klass = _cp->resolved_klass_at(super_class_index);
+            if (pick_newest) {
+                resolved_klass = resolved_klass->newest_version();
+            }
+            super_klass = InstanceKlass::cast(resolved_klass);
       if (need_verify)
         is_array = super_klass->is_array_klass();
     } else if (need_verify) {
@@ -4229,7 +4243,9 @@
   if (!_has_empty_finalizer) {
     if (_has_finalizer ||
         (super != NULL && super->has_finalizer())) {
-      ik->set_has_finalizer();
+        if (_old_klass.is_null() || _old_klass->has_finalizer()) {
+            ik->set_has_finalizer();
+        }
     }
   }

@@ -4251,7 +4267,7 @@

   // Check if this klass supports the java.lang.Cloneable interface
   if (SystemDictionary::Cloneable_klass_loaded()) {
-    if (ik->is_subtype_of(SystemDictionary::Cloneable_klass())) {
+    if (ik->is_subtype_of(SystemDictionary::Cloneable_klass()) || ik->is_subtype_of(SystemDictionary::Cloneable_klass()->newest_version())) {
       ik->set_is_cloneable();
     }
   }
@@ -5255,7 +5272,11 @@
   if (_klass != NULL) {
     return _klass;
   }
-
+
+  if(!_was_fully_parsed) {
+      return NULL;
+  }
+
   InstanceKlass* const ik =
     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);

@@ -5559,7 +5580,9 @@
                                  ClassLoaderData* loader_data,
                                  Handle protection_domain,
                                  const InstanceKlass* host_klass,
+                                 const KlassHandle old_klass,
                                  GrowableArray<Handle>* cp_patches,
+                                 GrowableArray<Symbol*>* parsed_super_symbols,
                                  Publicity pub_level,
                                  TRAPS) :
   _stream(stream),
@@ -5567,6 +5590,8 @@
   _loader_data(loader_data),
   _host_klass(host_klass),
   _cp_patches(cp_patches),
+  _parsed_super_symbols(parsed_super_symbols),
+  _old_klass(old_klass),
   _super_klass(),
   _cp(NULL),
   _fields(NULL),
@@ -5613,6 +5638,7 @@
   _has_finalizer(false),
   _has_empty_finalizer(false),
   _has_vanilla_constructor(false),
+  _was_fully_parsed(false),
   _max_bootstrap_specifier_index(-1) {

   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
@@ -5645,9 +5671,12 @@
   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
   _relax_verify = relax_format_check_for(_loader_data);

-  parse_stream(stream, CHECK);
-
-  post_process_parsed_stream(stream, _cp, CHECK);
+  int should_post_process = parse_stream(stream, CHECK);
+
+  if (should_post_process == POST_PROCESSING_DO) {
+    _was_fully_parsed = true;
+    post_process_parsed_stream(stream, _cp, CHECK);
+  }
 }

 void ClassFileParser::clear_class_metadata() {
@@ -5719,19 +5748,20 @@
   }
 }

-void ClassFileParser::parse_stream(const ClassFileStream* const stream,
+int ClassFileParser::parse_stream(const ClassFileStream* const stream,
                                    TRAPS) {

   assert(stream != NULL, "invariant");
   assert(_class_name != NULL, "invariant");

+  bool pick_newest = !_old_klass.is_null();
   // BEGIN STREAM PARSING
-  stream->guarantee_more(8, CHECK);  // magic, major, minor
+  stream->guarantee_more(8, CHECK_(POST_PROCESSING_SKIP));  // magic, major, minor
   // Magic value
   const u4 magic = stream->get_u4_fast();
   guarantee_property(magic == JAVA_CLASSFILE_MAGIC,
                      "Incompatible magic value %u in class file %s",
-                     magic, CHECK);
+                     magic, CHECK_(POST_PROCESSING_SKIP));

   // Version numbers
   _minor_version = stream->get_u2_fast();
@@ -5762,28 +5792,28 @@
       _minor_version,
       JAVA_MAX_SUPPORTED_VERSION,
       JAVA_MAX_SUPPORTED_MINOR_VERSION);
-    return;
-  }
-
-  stream->guarantee_more(3, CHECK); // length, first cp tag
+    return POST_PROCESSING_SKIP;
+  }
+
+  stream->guarantee_more(3, CHECK_(POST_PROCESSING_SKIP)); // length, first cp tag
   const u2 cp_size = stream->get_u2_fast();

   guarantee_property(
     cp_size >= 1, "Illegal constant pool size %u in class file %s",
-    cp_size, CHECK);
+    cp_size, CHECK_(POST_PROCESSING_SKIP));

   _cp = ConstantPool::allocate(_loader_data,
                                cp_size,
-                               CHECK);
+                               CHECK_(POST_PROCESSING_SKIP));

   ConstantPool* const cp = _cp;

-  parse_constant_pool(stream, cp, cp_size, CHECK);
+  parse_constant_pool(stream, cp, cp_size, CHECK_(POST_PROCESSING_SKIP));

   assert(cp_size == (const u2)cp->length(), "invariant");

   // ACCESS FLAGS
-  stream->guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
+  stream->guarantee_more(8, CHECK_(POST_PROCESSING_SKIP));  // flags, this_class, super_class, infs_len

   // Access flags
   jint flags;
@@ -5799,13 +5829,13 @@
     flags |= JVM_ACC_ABSTRACT;
   }

-  verify_legal_class_modifiers(flags, CHECK);
+  verify_legal_class_modifiers(flags, CHECK_(POST_PROCESSING_SKIP));

   short bad_constant = class_bad_constant_seen();
   if (bad_constant != 0) {
     // Do not throw CFE until after the access_flags are checked because if
     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
-    classfile_parse_error("Unknown constant tag %u in class file %s", bad_constant, CHECK);
+    classfile_parse_error("Unknown constant tag %u in class file %s", bad_constant, CHECK_(POST_PROCESSING_SKIP));
   }

   _access_flags.set_flags(flags);
@@ -5816,7 +5846,7 @@
     valid_cp_range(_this_class_index, cp_size) &&
       cp->tag_at(_this_class_index).is_unresolved_klass(),
     "Invalid this class index %u in constant pool in class file %s",
-    _this_class_index, CHECK);
+    _this_class_index, CHECK_(POST_PROCESSING_SKIP));

   Symbol* const class_name_in_cp = cp->klass_name_at(_this_class_index);
   assert(class_name_in_cp != NULL, "class_name can't be null");
@@ -5831,9 +5861,28 @@
   if (_need_verify) {
     guarantee_property(_class_name->byte_at(0) != JVM_SIGNATURE_ARRAY,
                        "Bad class name in class file %s",
-                       CHECK);
-  }
-
+                       CHECK_(POST_PROCESSING_SKIP));
+  }
+
+  // (DCEVM) Do not parse full class file, only get super symbols and return.
+    if (_parsed_super_symbols != NULL) {
+        u2 super_class_index = stream->get_u2_fast();
+
+        if (super_class_index != 0) {
+            _parsed_super_symbols->append(cp->klass_name_at(super_class_index));
+        }
+
+        // Interfaces
+        u2 itfs_len = stream->get_u2_fast();
+        parse_interfaces(stream, itfs_len, cp, pick_newest, &_has_nonstatic_concrete_methods, CHECK_(POST_PROCESSING_SKIP));
+
+        for (int i = 0; i < _local_interfaces->length(); i++) {
+            Klass* o = _local_interfaces->at(i);
+            _parsed_super_symbols->append(o->name());
+        }
+        return POST_PROCESSING_SKIP;
+    }
+
   // Checks if name in class file matches requested name
   if (_requested_name != NULL && _requested_name != _class_name) {
     ResourceMark rm(THREAD);
@@ -5844,14 +5893,14 @@
       _class_name->as_C_string(),
       _requested_name != NULL ? _requested_name->as_C_string() : "NoName"
     );
-    return;
+    return POST_PROCESSING_SKIP;
   }

   // if this is an anonymous class fix up its name if it's in the unnamed
   // package.  Otherwise, throw IAE if it is in a different package than
   // its host class.
   if (_host_klass != NULL) {
-    fix_anonymous_class_name(CHECK);
+    fix_anonymous_class_name(CHECK_(POST_PROCESSING_SKIP));
   }

   // Verification prevents us from creating names with dots in them, this
@@ -5900,16 +5949,16 @@
   _super_class_index = stream->get_u2_fast();
   _super_klass = parse_super_class(cp,
                                    _super_class_index,
-                                   _need_verify,
-                                   CHECK);
+                                   _need_verify, pick_newest,
+                                   CHECK_(POST_PROCESSING_SKIP));

   // Interfaces
   _itfs_len = stream->get_u2_fast();
   parse_interfaces(stream,
                    _itfs_len,
-                   cp,
+                   cp, pick_newest,
                    &_has_nonstatic_concrete_methods,
-                   CHECK);
+                   CHECK_(POST_PROCESSING_SKIP));

   assert(_local_interfaces != NULL, "invariant");

@@ -5921,7 +5970,7 @@
                cp,
                cp_size,
                &_java_fields_count,
-               CHECK);
+               CHECK_(POST_PROCESSING_SKIP));

   assert(_fields != NULL, "invariant");

@@ -5932,7 +5981,7 @@
                 &promoted_flags,
                 &_has_final_method,
                 &_declares_nonstatic_concrete_methods,
-                CHECK);
+                CHECK_(POST_PROCESSING_SKIP));

   assert(_methods != NULL, "invariant");

@@ -5945,20 +5994,21 @@

   // Additional attributes/annotations
   _parsed_annotations = new ClassAnnotationCollector();
-  parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
+  parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK_(POST_PROCESSING_SKIP));

   assert(_inner_classes != NULL, "invariant");

   // Finalize the Annotations metadata object,
   // now that all annotation arrays have been created.
-  create_combined_annotations(CHECK);
+  create_combined_annotations(CHECK_(POST_PROCESSING_SKIP));

   // Make sure this is the end of class file stream
   guarantee_property(stream->at_eos(),
                      "Extra bytes at the end of class file %s",
-                     CHECK);
+                     CHECK_(POST_PROCESSING_SKIP));

   // all bytes in stream read and parsed
+  return POST_PROCESSING_DO;
 }

 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
@@ -5991,6 +6041,10 @@
                                                                _protection_domain,
                                                                true,
                                                                CHECK);
+    bool pick_newest = !_old_klass.is_null();
+    if (pick_newest && _super_klass != NULL) {
+            _super_klass = (const InstanceKlass*) _super_klass->newest_version();
+        }
   }

   if (_super_klass != NULL) {
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/classFileParser.hpp
--- a/src/share/vm/classfile/classFileParser.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/classFileParser.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -80,6 +80,9 @@
   Symbol* _class_name;
   mutable ClassLoaderData* _loader_data;
   const InstanceKlass* _host_klass;
+  const KlassHandle _old_klass;
+  GrowableArray<Symbol*>* _parsed_super_symbols;
+  bool _was_fully_parsed; //(DCEVM) store if everything was parsed
   GrowableArray<Handle>* _cp_patches; // overrides for CP entries

   // Metadata created before the instance klass is created.  Must be deallocated
@@ -158,7 +161,7 @@
   bool _has_vanilla_constructor;
   int _max_bootstrap_specifier_index;  // detects BSS values

-  void parse_stream(const ClassFileStream* const stream, TRAPS);
+  int parse_stream(const ClassFileStream* const stream, TRAPS);

   void post_process_parsed_stream(const ClassFileStream* const stream,
                                   ConstantPool* cp,
@@ -196,12 +199,12 @@
   // Interface parsing
   void parse_interfaces(const ClassFileStream* const stream,
                         const int itfs_len,
-                        ConstantPool* const cp,
+                        ConstantPool* const cp, bool pick_newest,
                         bool* has_nonstatic_concrete_methods,
                         TRAPS);

   const InstanceKlass* parse_super_class(ConstantPool* const cp,
-                                         const int super_class_index,
+                                         const int super_class_index, bool pick_newest,
                                          const bool need_verify,
                                          TRAPS);

@@ -489,7 +492,9 @@
                   ClassLoaderData* loader_data,
                   Handle protection_domain,
                   const InstanceKlass* host_klass,
+                  const KlassHandle old_klass,
                   GrowableArray<Handle>* cp_patches,
+                  GrowableArray<Symbol*>* parsed_super_symbols,
                   Publicity pub_level,
                   TRAPS);

@@ -526,7 +531,7 @@
   bool is_internal() const { return INTERNAL == _pub_level; }

   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
-
+
 #ifdef ASSERT
   static bool is_internal_format(Symbol* class_name);
 #endif
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/classLoader.cpp
--- a/src/share/vm/classfile/classLoader.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/classLoader.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -1517,7 +1517,9 @@
                                                                 loader_data,
                                                                 protection_domain,
                                                                 NULL, // host_klass
+                                                                KlassHandle(), //old class
                                                                 NULL, // cp_patches
+                                                                NULL, //parsed super symbols
                                                                 THREAD);
   if (HAS_PENDING_EXCEPTION) {
     if (DumpSharedSpaces) {
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/dictionary.cpp
--- a/src/share/vm/classfile/dictionary.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/dictionary.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -158,7 +158,7 @@
       InstanceKlass* ik = InstanceKlass::cast(e);
 
       // Non-unloadable classes were handled in always_strong_oops_do
-      if (!is_strongly_reachable(loader_data, e)) {
+      if (!ik->is_redefining() && !is_strongly_reachable(loader_data, e)) {
         // Entry was not visited in phase1 (negated test from phase1)
         assert(!loader_data->is_the_null_class_loader_data(), "unloading entry with null class loader");
         ClassLoaderData* k_def_class_loader_data = ik->class_loader_data();
@@ -383,6 +383,32 @@
   add_entry(index, entry);
 }
 
+// (DCEVM) Updates the klass entry to point to the new Klass*. Necessary only for class redefinition.
+bool Dictionary::update_klass(int index, unsigned int hash, Symbol* name, ClassLoaderData* loader_data, KlassHandle k, KlassHandle old_class) {
+
+  // There are several entries for the same class in the dictionary: One extra entry for each parent classloader of the classloader of the class.
+  bool found = false;
+  for (int index = 0; index < table_size(); index++) {
+    for (DictionaryEntry* entry = bucket(index); entry != NULL; entry = entry->next()) {
+      if (entry->klass() == old_class()) {
+        entry->set_literal(k());
+        found = true;
+      }
+    }
+  }
+  return found;
+}
+
+// (DCEVM) Undo previous updates to the system dictionary
+void Dictionary::rollback_redefinition() {
+  for (int index = 0; index < table_size(); index++) {
+    for (DictionaryEntry* entry = bucket(index); entry != NULL; entry = entry->next()) {
+      if (entry->klass()->is_redefining()) {
+        entry->set_literal(entry->klass()->old_version());
+      }
+    }
+  }
+}
 
 // This routine does not lock the system dictionary.
 //
@@ -414,7 +440,7 @@
                           ClassLoaderData* loader_data, Handle protection_domain, TRAPS) {
   DictionaryEntry* entry = get_entry(index, hash, name, loader_data);
   if (entry != NULL && entry->is_valid_protection_domain(protection_domain)) {
-    return entry->klass();
+    return intercept_for_version(entry->klass());
   } else {
     return NULL;
   }
@@ -427,7 +453,7 @@
   assert (index == index_for(name, loader_data), "incorrect index?");
 
   DictionaryEntry* entry = get_entry(index, hash, name, loader_data);
-  return (entry != NULL) ? entry->klass() : (Klass*)NULL;
+  return intercept_for_version((entry != NULL) ? entry->klass() : (Klass*)NULL);
 }
 
 
@@ -439,7 +465,7 @@
   assert (index == index_for(name, NULL), "incorrect index?");
 
   DictionaryEntry* entry = get_entry(index, hash, name, NULL);
-  return (entry != NULL) ? entry->klass() : (Klass*)NULL;
+  return intercept_for_version((entry != NULL) ? entry->klass() : (Klass*)NULL);
 }
 
 
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/dictionary.hpp
--- a/src/share/vm/classfile/dictionary.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/dictionary.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -81,6 +81,10 @@
 
   void add_klass(Symbol* class_name, ClassLoaderData* loader_data,KlassHandle obj);
 
+  bool update_klass(int index, unsigned int hash, Symbol* name, ClassLoaderData* loader_data, KlassHandle k, KlassHandle old_class);
+
+  void rollback_redefinition();
+
   Klass* find_class(int index, unsigned int hash,
                       Symbol* name, ClassLoaderData* loader_data);
 
@@ -112,6 +116,11 @@
     return (loader_data->is_the_null_class_loader_data() || !ClassUnloading);
   }
 
+  // (DCEVM) During enhanced class redefinition we want old version if new is being redefined
+  static Klass* intercept_for_version(Klass* k) {
+    return (k != NULL && k->is_redefining()) ? k->old_version() : k;
+  }
+ 
   // Unload (that is, break root links to) all unmarked classes and loaders.
   void do_unloading();
 
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/javaClasses.cpp
--- a/src/share/vm/classfile/javaClasses.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/javaClasses.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -2030,6 +2030,8 @@
         skip_throwableInit_check = true;
       }
     }
+    // (DCEVM): Line numbers from newest version must be used for EMCP-swapped methods
+    method = method->newest_version();
     if (method->is_hidden()) {
       if (skip_hidden)  continue;
     }
@@ -3881,6 +3883,9 @@
   java_lang_StackFrameInfo::compute_offsets();
   java_lang_LiveStackFrameInfo::compute_offsets();
 
+  java_lang_invoke_DirectMethodHandle_StaticAccessor::compute_offsets();
+  java_lang_invoke_DirectMethodHandle_Accessor::compute_offsets();
+  
   // generated interpreter code wants to know about the offsets we just computed:
   AbstractAssembler::update_delayed_values();
 }
@@ -4105,3 +4110,49 @@
   JavaClasses::check_offsets();
   FilteredFieldsMap::initialize();  // must be done after computing offsets.
 }
+
+// Support for java_lang_invoke_DirectMethodHandle$StaticAccessor
+int java_lang_invoke_DirectMethodHandle_StaticAccessor::_static_offset_offset;
+
+long java_lang_invoke_DirectMethodHandle_StaticAccessor::static_offset(oop dmh) {
+    assert(_static_offset_offset != 0, "");
+    return dmh->long_field(_static_offset_offset);
+    
+}
+
+void java_lang_invoke_DirectMethodHandle_StaticAccessor::set_static_offset(oop dmh, long static_offset) {
+    assert(_static_offset_offset != 0, "");
+    dmh->long_field_put(_static_offset_offset, static_offset);
+    
+}
+
+void java_lang_invoke_DirectMethodHandle_StaticAccessor::compute_offsets() {
+    Klass* klass_oop = SystemDictionary::DirectMethodHandle_StaticAccessor_klass();
+    if (klass_oop != NULL) {
+        compute_offset(_static_offset_offset, klass_oop, vmSymbols::static_offset_name(), vmSymbols::long_signature());
+           }
+    
+}
+
+// Support for java_lang_invoke_DirectMethodHandle$Accessor
+int java_lang_invoke_DirectMethodHandle_Accessor::_field_offset_offset;
+
+int java_lang_invoke_DirectMethodHandle_Accessor::field_offset(oop dmh) {
+    assert(_field_offset_offset != 0, "");
+    return dmh->int_field(_field_offset_offset);
+    
+}
+
+void java_lang_invoke_DirectMethodHandle_Accessor::set_field_offset(oop dmh, int field_offset) {
+    assert(_field_offset_offset != 0, "");
+    dmh->int_field_put(_field_offset_offset, field_offset);
+    
+}
+
+void java_lang_invoke_DirectMethodHandle_Accessor::compute_offsets() {
+    Klass* klass_oop = SystemDictionary::DirectMethodHandle_Accessor_klass();
+    if (klass_oop != NULL) {
+        compute_offset(_field_offset_offset, klass_oop, vmSymbols::field_offset_name(), vmSymbols::int_signature());
+            }
+    
+}
\ No newline at end of file
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/javaClasses.hpp
--- a/src/share/vm/classfile/javaClasses.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/javaClasses.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -980,6 +980,63 @@
   static int member_offset_in_bytes()           { return _member_offset; }
 };
 
+// Interface to java.lang.invoke.DirectMethodHandle$StaticAccessor objects
+class java_lang_invoke_DirectMethodHandle_StaticAccessor : AllStatic {
+    friend class JavaClasses;
+    
+    
+private:
+     static int _static_offset_offset; // offset to static field
+    
+     static void compute_offsets();
+    
+    
+public:
+     // Accessors
+    static long static_offset(oop dmh);
+    static void set_static_offset(oop dmh, long value);
+
+    
+     // Testers
+    static bool is_subclass(Klass* klass) {
+        return klass->is_subclass_of(SystemDictionary::DirectMethodHandle_StaticAccessor_klass());
+            }
+
+    static bool is_instance(oop obj) {
+        return obj != NULL && is_subclass(obj->klass());
+           }
+    
+};
+
+
+// Interface to java.lang.invoke.DirectMethodHandle$Accessor objects
+class java_lang_invoke_DirectMethodHandle_Accessor : AllStatic {
+    friend class JavaClasses;
+    
+    
+private:
+     static int _field_offset_offset; // offset to field
+    
+     static void compute_offsets();
+    
+    
+public:
+     // Accessors
+     static int field_offset(oop dmh);
+    static void set_field_offset(oop dmh, int value);
+
+    
+     // Testers
+     static bool is_subclass(Klass* klass) {
+        return klass->is_subclass_of(SystemDictionary::DirectMethodHandle_Accessor_klass());
+            }
+
+    static bool is_instance(oop obj) {
+        return obj != NULL && is_subclass(obj->klass());
+            }
+    
+};
+
 // Interface to java.lang.invoke.LambdaForm objects
 // (These are a private interface for managing adapter code generation.)
 
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/klassFactory.cpp
--- a/src/share/vm/classfile/klassFactory.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/klassFactory.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -82,6 +82,8 @@
                              protection_domain,
                              NULL,
                              NULL,
+                             NULL,
+                             NULL,
                              ClassFileParser::BROADCAST, // publicity level
                              CHECK_NULL);
       instanceKlassHandle new_ik = parser.create_instance_klass(true /* changed_by_loadhook */,
@@ -106,6 +108,7 @@
 
 static ClassFileStream* check_class_file_load_hook(ClassFileStream* stream,
                                                    Symbol* name,
+                                                   GrowableArray<Symbol*>* parsed_super_symbols,
                                                    ClassLoaderData* loader_data,
                                                    Handle protection_domain,
                                                    JvmtiCachedClassFileData** cached_class_file,
@@ -113,7 +116,7 @@
 
   assert(stream != NULL, "invariant");
 
-  if (JvmtiExport::should_post_class_file_load_hook()) {
+  if (parsed_super_symbols == NULL && JvmtiExport::should_post_class_file_load_hook()) {
     assert(THREAD->is_Java_thread(), "must be a JavaThread");
     const JavaThread* jt = (JavaThread*)THREAD;
 
@@ -168,7 +171,9 @@
                                                      ClassLoaderData* loader_data,
                                                      Handle protection_domain,
                                                      const InstanceKlass* host_klass,
+                                                     const KlassHandle old_klass,
                                                      GrowableArray<Handle>* cp_patches,
+                                                     GrowableArray<Symbol*>* parsed_super_symbols,
                                                      TRAPS) {
   assert(stream != NULL, "invariant");
   assert(loader_data != NULL, "invariant");
@@ -185,6 +190,7 @@
   if (host_klass == NULL) {
     stream = check_class_file_load_hook(stream,
                                         name,
+                                        parsed_super_symbols,
                                         loader_data,
                                         protection_domain,
                                         &cached_class_file,
@@ -196,7 +202,9 @@
                          loader_data,
                          protection_domain,
                          host_klass,
+                         old_klass,
                          cp_patches,
+                         parsed_super_symbols,
                          ClassFileParser::BROADCAST, // publicity level
                          CHECK_NULL);
 
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/klassFactory.hpp
--- a/src/share/vm/classfile/klassFactory.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/klassFactory.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -66,6 +66,7 @@
   friend class ClassLoader;
   friend class ClassLoaderExt;
   friend class SystemDictionary;
+friend class VM_EnhancedRedefineClasses;
 
  private:
   static instanceKlassHandle create_from_stream(ClassFileStream* stream,
@@ -73,7 +74,9 @@
                                                 ClassLoaderData* loader_data,
                                                 Handle protection_domain,
                                                 const InstanceKlass* host_klass,
+                                                const KlassHandle old_klass,
                                                 GrowableArray<Handle>* cp_patches,
+                                                GrowableArray<Symbol*>* parsed_super_symbols,
                                                 TRAPS);
  public:
   static instanceKlassHandle check_shared_class_file_load_hook(
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/loaderConstraints.cpp
--- a/src/share/vm/classfile/loaderConstraints.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/loaderConstraints.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -98,6 +98,19 @@
   return pp;
 }
 
+void LoaderConstraintTable::update_after_redefinition() {
+  for (int index = 0; index < table_size(); index++) {
+    LoaderConstraintEntry** p = bucket_addr(index);
+    while(*p) {
+      LoaderConstraintEntry* probe = *p;
+      if (probe->klass() != NULL) {
+        // We swap the class with the newest version with an assumption that the hash will be the same
+        probe->set_klass(probe->klass()->newest_version());
+      }
+      p = probe->next_addr();
+    }
+  }
+}
 
 void LoaderConstraintTable::purge_loader_constraints() {
   assert(SafepointSynchronize::is_at_safepoint(), "must be at safepoint");
@@ -457,7 +470,7 @@
         if (k != NULL) {
           // We found the class in the system dictionary, so we should
           // make sure that the Klass* matches what we already have.
-          guarantee(k == probe->klass(), "klass should be in dictionary");
+          guarantee(k == probe->klass()->newest_version(), "klass should be in dictionary");
         } else {
           // If we don't find the class in the system dictionary, it
           // has to be in the placeholders table.
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/loaderConstraints.hpp
--- a/src/share/vm/classfile/loaderConstraints.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/loaderConstraints.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -64,6 +64,9 @@
   // Enhanced Class Redefinition support
   void classes_do(KlassClosure* f);
 
+  // (DCEVM) update all klasses with newest version
+  void update_after_redefinition();
+
   // Check class loader constraints
   bool add_entry(Symbol* name, Klass* klass1, Handle loader1,
                                     Klass* klass2, Handle loader2);
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/systemDictionary.cpp
--- a/src/share/vm/classfile/systemDictionary.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/systemDictionary.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -188,6 +188,7 @@
     // can return a null klass
     klass = handle_resolution_exception(class_name, throw_error, k_h, THREAD);
   }
+  assert(klass == NULL || klass->is_newest_version() || klass->newest_version()->is_redefining(), "must be");
   return klass;
 }
 
@@ -232,7 +233,7 @@
 // Forwards to resolve_instance_class_or_null
 
 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
-  assert(THREAD->can_call_java(),
+  assert(THREAD->can_call_java() || JvmtiThreadState::state_for(JavaThread::current())->get_class_being_redefined() != NULL,
          "can not load classes with compiler thread: class=%s, classloader=%s",
          class_name->as_C_string(),
          class_loader.is_null() ? "null" : class_loader->klass()->name()->as_C_string());
@@ -1052,7 +1053,8 @@
                                                            loader_data,
                                                            protection_domain,
                                                            host_klass,
-                                                           cp_patches,
+                                                           KlassHandle(),
+                                                           cp_patches, NULL,
                                                            CHECK_NULL);
 
   if (host_klass != NULL && k.not_null()) {
@@ -1101,6 +1103,7 @@
                                              Handle class_loader,
                                              Handle protection_domain,
                                              ClassFileStream* st,
+                                             KlassHandle oldKlass,
                                              TRAPS) {
 
   // Classloaders that support parallelism, e.g. bootstrap classloader,
@@ -1144,10 +1147,18 @@
                                          loader_data,
                                          protection_domain,
                                          NULL, // host_klass
+                                         oldKlass, //old klass
                                          NULL, // cp_patches
+                                         NULL, //parsed super symbol
                                          CHECK_NULL);
   }
 
+  // (DCEVM) During enhanced class redefinition, mark loaded class as being redefined
+    if (!oldKlass.is_null() && !k.is_null()) {
+        k->set_redefining(true);
+        k->set_old_version(oldKlass());
+    }
+  
   assert(k.not_null(), "no klass created");
   Symbol* h_name = k->name();
   assert(class_name == NULL || class_name == h_name, "name mismatch");
@@ -1155,7 +1166,8 @@
   // Add class just loaded
   // If a class loader supports parallel classloading handle parallel define requests
   // find_or_define_instance_class may return a different InstanceKlass
-  if (is_parallelCapable(class_loader)) {
+  // (DCEVM) TODO: for class redefinition the parallel version does not work, check if this is a problem?
+  if (is_parallelCapable(class_loader) && oldKlass.is_null()) {
     instanceKlassHandle defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
     if (!HAS_PENDING_EXCEPTION && defined_k() != k()) {
       // If a parallel capable class loader already defined this class, register 'k' for cleanup.
@@ -1164,7 +1176,7 @@
       k = defined_k;
     }
   } else {
-    define_instance_class(k, THREAD);
+    define_instance_class(k, oldKlass, THREAD);
   }
 
   // If defining the class throws an exception register 'k' for cleanup.
@@ -1179,7 +1191,7 @@
     MutexLocker mu(SystemDictionary_lock, THREAD);
 
     Klass* check = find_class(h_name, k->class_loader_data());
-    assert(check == k(), "should be present in the dictionary");
+    assert(check == k() && !k->is_redefining()) || (k->is_redefining() && check == k->old_version(), "should be present in the dictionary");
   } );
 
   return k();
@@ -1612,7 +1624,11 @@
   }
 }
 
-void SystemDictionary::define_instance_class(instanceKlassHandle k, TRAPS) {
+void SystemDictionary::rollback_redefinition() {
+  dictionary()->rollback_redefinition();
+}
+
+void SystemDictionary::define_instance_class(instanceKlassHandle k, KlassHandle old_class, TRAPS) {
 
   ClassLoaderData* loader_data = k->class_loader_data();
   Handle class_loader_h(THREAD, loader_data->class_loader());
@@ -1640,7 +1656,17 @@
   Symbol*  name_h = k->name();
   unsigned int d_hash = dictionary()->compute_hash(name_h, loader_data);
   int d_index = dictionary()->hash_to_index(d_hash);
-  check_constraints(d_index, d_hash, k, class_loader_h, true, CHECK);
+
+  // (DCEVM) Update version of the Klass* in the system dictionary
+  // TODO: Check for thread safety!
+  if (!old_class.is_null()) {
+    bool ok = dictionary()->update_klass(d_index, d_hash, name_h, loader_data, k, old_class);
+    assert (ok, "must have found old class and updated!");
+  }
+  check_constraints(d_index, d_hash, k, class_loader_h, old_class.is_null(), CHECK);
+
+  // FIXME: (DCEVM) clean this...
+  if(!old_class.is_null() && TraceRedefineClasses >= 3){ tty->print_cr("Class has been updated!"); }
 
   // Register class just loaded with class loader (placed in Vector)
   // Note we do this before updating the dictionary, as this can
@@ -1673,8 +1699,9 @@
   }
   k->eager_initialize(THREAD);
 
+  // (DCEVM) Only notify jvmti if not redefining a class.
   // notify jvmti
-  if (JvmtiExport::should_post_class_load()) {
+  if (JvmtiExport::should_post_class_load() && old_class.is_null()) {
       assert(THREAD->is_Java_thread(), "thread->is_Java_thread()");
       JvmtiExport::post_class_load((JavaThread *) THREAD, k());
 
@@ -1752,7 +1779,7 @@
     }
   }
 
-  define_instance_class(k, THREAD);
+  define_instance_class(k, KlassHandle(), THREAD);
 
   Handle linkage_exception = Handle(); // null handle
 
@@ -1861,6 +1888,19 @@
   return dictionary()->try_get_next_class();
 }
 
+// (DCEVM) Remove from hierarchy - Undo add_to_hierarchy.
+void SystemDictionary::remove_from_hierarchy(instanceKlassHandle k) {
+  assert(k.not_null(), "just checking");
+
+  // remove receiver from sibling list
+  k->remove_from_sibling_list();
+  // TODO (DCEVM): Remove from interfaces.
+}
+
+// (DCEVM) Update constraints
+void SystemDictionary::update_constraints_after_redefinition() {
+  constraints()->update_after_redefinition();
+}
 
 // ----------------------------------------------------------------------------
 // Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Recompile_lock
@@ -2250,7 +2290,7 @@
       // also holds array classes
 
       assert(check->is_instance_klass(), "noninstance in systemdictionary");
-      if ((defining == true) || (k() != check)) {
+      if ((defining == true) || (k() != check && k->old_version() != check)) {
         linkage_error1 = "loader (instance of  ";
         linkage_error2 = "): attempted  duplicate class definition for name: \"";
       } else {
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/systemDictionary.hpp
--- a/src/share/vm/classfile/systemDictionary.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/systemDictionary.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -152,6 +152,8 @@
                                                                                                                          \
   /* support for dynamic typing; it's OK if these are NULL in earlier JDKs */                                            \
   do_klass(DirectMethodHandle_klass,                    java_lang_invoke_DirectMethodHandle,       Opt                 ) \
+  do_klass(DirectMethodHandle_StaticAccessor_klass,     java_lang_invoke_DirectMethodHandle_StaticAccessor, Opt        ) \
+  do_klass(DirectMethodHandle_Accessor_klass,           java_lang_invoke_DirectMethodHandle_Accessor, Opt              ) \
   do_klass(MethodHandle_klass,                          java_lang_invoke_MethodHandle,             Pre                 ) \
   do_klass(VarHandle_klass,                             java_lang_invoke_VarHandle,                Pre                 ) \
   do_klass(MemberName_klass,                            java_lang_invoke_MemberName,               Pre                 ) \
@@ -308,6 +310,7 @@
                                     Handle class_loader,
                                     Handle protection_domain,
                                     ClassFileStream* st,
+                                    KlassHandle oldKlass,
                                     TRAPS);
 
   // Lookup an already loaded class. If not found NULL is returned.
@@ -383,6 +386,12 @@
   // System loader lock
   static oop system_loader_lock()           { return _system_loader_lock_obj; }
 
+  // (DCEVM) Remove link to hierarchy
+  static void remove_from_hierarchy(instanceKlassHandle k);
+
+  // (DCEVM) Update constraints
+  static void update_constraints_after_redefinition();
+
 protected:
   // Extended Redefine classes support (tbi)
   static void preloaded_classes_do(KlassClosure* f);
@@ -435,6 +444,9 @@
     initialize_wk_klasses_until((WKID) limit, start_id, THREAD);
   }
 
+  // (DCEVM) rollback class redefinition
+  static void rollback_redefinition();
+
 public:
   #define WK_KLASS_DECLARE(name, symbol, option) \
     static InstanceKlass* name() { return check_klass_##option(_well_known_klasses[WK_KLASS_ENUM_NAME(name)]); } \
@@ -637,7 +649,7 @@
   // after waiting, but before reentering SystemDictionary_lock
   // to preserve lock order semantics.
   static void double_lock_wait(Handle lockObject, TRAPS);
-  static void define_instance_class(instanceKlassHandle k, TRAPS);
+  static void define_instance_class(instanceKlassHandle k, KlassHandle old_class, TRAPS);
   static instanceKlassHandle find_or_define_instance_class(Symbol* class_name,
                                                 Handle class_loader,
                                                 instanceKlassHandle k, TRAPS);
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/verifier.cpp
--- a/src/share/vm/classfile/verifier.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/verifier.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -228,7 +228,7 @@
   Symbol* name = klass->name();
   Klass* refl_magic_klass = SystemDictionary::reflect_MagicAccessorImpl_klass();
 
-  bool is_reflect = refl_magic_klass != NULL && klass->is_subtype_of(refl_magic_klass);
+  bool is_reflect = refl_magic_klass != NULL && (klass->is_subtype_of(refl_magic_klass) || klass->is_subtype_of(refl_magic_klass->newest_version()));
 
   return (should_verify_for(klass->class_loader(), should_verify_class) &&
     // return if the class is a bootstrapping class
@@ -560,7 +560,7 @@
 
 ClassVerifier::ClassVerifier(
     instanceKlassHandle klass, TRAPS)
-    : _thread(THREAD), _exception_type(NULL), _message(NULL), _klass(klass) {
+    : _thread(THREAD), _exception_type(NULL), _message(NULL), _klass(klass->newest_version()), _klass_to_verify(klass) {
   _this_type = VerificationType::reference_type(klass->name());
   // Create list to hold symbols in reference area.
   _symbols = new GrowableArray<Symbol*>(100, 0, NULL);
@@ -587,7 +587,7 @@
 void ClassVerifier::verify_class(TRAPS) {
   log_info(verification)("Verifying class %s with new format", _klass->external_name());
 
-  Array<Method*>* methods = _klass->methods();
+  Array<Method*>* methods = _klass_to_verify->methods();
   int num_methods = methods->length();
 
   for (int index = 0; index < num_methods; index++) {
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/verifier.hpp
--- a/src/share/vm/classfile/verifier.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/verifier.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -348,6 +348,7 @@
 
   VerificationType object_type() const;
 
+  instanceKlassHandle _klass_to_verify;
   instanceKlassHandle _klass;  // the class being verified
   methodHandle        _method; // current method being verified
   VerificationType    _this_type; // the verification type of the current class
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/classfile/vmSymbols.hpp
--- a/src/share/vm/classfile/vmSymbols.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/classfile/vmSymbols.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -282,6 +282,8 @@
   template(java_lang_invoke_CallSite,                 "java/lang/invoke/CallSite")                \
   template(java_lang_invoke_ConstantCallSite,         "java/lang/invoke/ConstantCallSite")        \
   template(java_lang_invoke_DirectMethodHandle,       "java/lang/invoke/DirectMethodHandle")      \
+  template(java_lang_invoke_DirectMethodHandle_StaticAccessor, "java/lang/invoke/DirectMethodHandle$StaticAccessor") \
+  template(java_lang_invoke_DirectMethodHandle_Accessor, "java/lang/invoke/DirectMethodHandle$Accessor") \
   template(java_lang_invoke_MutableCallSite,          "java/lang/invoke/MutableCallSite")         \
   template(java_lang_invoke_VolatileCallSite,         "java/lang/invoke/VolatileCallSite")        \
   template(java_lang_invoke_MethodHandle,             "java/lang/invoke/MethodHandle")            \
@@ -459,6 +461,10 @@
   template(getProtectionDomain_signature,             "(Ljava/security/CodeSource;)Ljava/security/ProtectionDomain;") \
   template(url_code_signer_array_void_signature,      "(Ljava/net/URL;[Ljava/security/CodeSigner;)V") \
   template(module_entry_name,                         "module_entry")                             \
+  template(static_offset_name,                        "staticOffset")                             \
+  template(static_base_name,                          "staticBase")                               \
+  template(field_offset_name,                         "fieldOffset")                              \
+  template(field_type_name,                           "fieldType")                                \
                                                                                                   \
   /* name symbols needed by intrinsics */                                                         \
   VM_INTRINSICS_DO(VM_INTRINSIC_IGNORE, VM_SYMBOL_IGNORE, template, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE) \
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/gc/cms/compactibleFreeListSpace.cpp
--- a/src/share/vm/gc/cms/compactibleFreeListSpace.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/gc/cms/compactibleFreeListSpace.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -128,6 +128,12 @@
   _dictionary->set_par_lock(&_parDictionaryAllocLock);
 }
 
+HeapWord* CompactibleFreeListSpace::forward_compact_top(size_t size,
+        CompactPoint* cp, HeapWord* compact_top) {
+    ShouldNotReachHere();
+    return NULL;
+}
+
 // Like CompactibleSpace forward() but always calls cross_threshold() to
 // update the block offset table.  Removed initialize_threshold call because
 // CFLS does not use a block offset array for contiguous spaces.
@@ -1946,7 +1952,12 @@
 
 // Support for compaction
 void CompactibleFreeListSpace::prepare_for_compaction(CompactPoint* cp) {
-  scan_and_forward(this, cp);
+    if (!Universe::is_redefining_gc_run()) {
+        scan_and_forward(this, cp, false);
+    } else {
+        // Redefinition run
+        scan_and_forward(this, cp, true);
+    }
   // Prepare_for_compaction() uses the space between live objects
   // so that later phase can skip dead space quickly.  So verification
   // of the free lists doesn't work after.
@@ -1964,7 +1975,12 @@
 }
 
 void CompactibleFreeListSpace::compact() {
-  scan_and_compact(this);
+    if (!Universe::is_redefining_gc_run()) {
+        scan_and_compact(this, false);
+    } else {
+        // Redefinition run
+        scan_and_compact(this, true);
+}
 }
 
 // Fragmentation metric = 1 - [sum of (fbs**2) / (sum of fbs)**2]
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/gc/cms/compactibleFreeListSpace.hpp
--- a/src/share/vm/gc/cms/compactibleFreeListSpace.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/gc/cms/compactibleFreeListSpace.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -80,11 +80,11 @@
   template <typename SpaceType>
   friend void CompactibleSpace::scan_and_adjust_pointers(SpaceType* space);
   template <typename SpaceType>
-  friend void CompactibleSpace::scan_and_compact(SpaceType* space);
+  friend void CompactibleSpace::scan_and_compact(SpaceType* space, bool redefinition_run);
   template <typename SpaceType>
   friend void CompactibleSpace::verify_up_to_first_dead(SpaceType* space);
   template <typename SpaceType>
-  friend void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp);
+  friend void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp, bool redefinition_run);
 
   // "Size" of chunks of work (executed during parallel remark phases
   // of CMS collection); this probably belongs in CMSCollector, although
@@ -163,6 +163,7 @@
 
   // Support for compacting cms
   HeapWord* cross_threshold(HeapWord* start, HeapWord* end);
+  HeapWord* forward_compact_top(size_t size, CompactPoint* cp, HeapWord* compact_top);
   HeapWord* forward(oop q, size_t size, CompactPoint* cp, HeapWord* compact_top);
 
   // Initialization helpers.
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/gc/g1/heapRegion.cpp
--- a/src/share/vm/gc/g1/heapRegion.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/gc/g1/heapRegion.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -965,7 +965,13 @@
 }
 
 void HeapRegion::prepare_for_compaction(CompactPoint* cp) {
-  scan_and_forward(this, cp);
+    if (!Universe::is_redefining_gc_run()) {
+        scan_and_forward(this, cp, false);
+    } else {
+        // Redefinition run
+        // Redefinition run
+        scan_and_forward(this, cp, true);
+}
 }
 
 // G1OffsetTableContigSpace code; copied from space.cpp.  Hope this can go
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/gc/g1/heapRegion.hpp
--- a/src/share/vm/gc/g1/heapRegion.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/gc/g1/heapRegion.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -224,7 +224,7 @@
   friend class VMStructs;
   // Allow scan_and_forward to call (private) overrides for auxiliary functions on this class
   template <typename SpaceType>
-  friend void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp);
+  friend void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp, bool redefinition_run);
  private:
 
   // The remembered set for this region.
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/gc/serial/genMarkSweep.cpp
--- a/src/share/vm/gc/serial/genMarkSweep.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/gc/serial/genMarkSweep.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -328,10 +328,15 @@
   // in the same order in phase2, phase3 and phase4. We don't quite do that
   // here (perm_gen first rather than last), so we tell the validate code
   // to use a higher index (saved from phase2) when verifying perm_gen.
+  assert(_rescued_oops == NULL, "must be empty before processing");
   GenCollectedHeap* gch = GenCollectedHeap::heap();
 
   GCTraceTime(Info, gc, phases) tm("Phase 4: Move objects", _gc_timer);
 
+  MarkSweep::copy_rescued_objects_back();
+  
   GenCompactClosure blk;
   gch->generation_iterate(&blk, true);
+  
+  MarkSweep::copy_rescued_objects_back();
 }
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/gc/serial/markSweep.cpp
--- a/src/share/vm/gc/serial/markSweep.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/gc/serial/markSweep.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -64,6 +64,107 @@
 CLDToOopClosure               MarkSweep::follow_cld_closure(&mark_and_push_closure);
 CLDToOopClosure               MarkSweep::adjust_cld_closure(&adjust_pointer_closure);
 
+GrowableArray<HeapWord*>* MarkSweep::_rescued_oops = NULL;
+
+// (DCEVM) Copy the rescued objects to their destination address after compaction.
+void MarkSweep::copy_rescued_objects_back() {
+    
+    if (_rescued_oops != NULL) {
+        
+        for (int i = 0; i < _rescued_oops->length(); i++) {
+            HeapWord* rescued_ptr = _rescued_oops->at(i);
+            oop rescued_obj = (oop) rescued_ptr;
+            
+            int size = rescued_obj->size();
+            oop new_obj = rescued_obj->forwardee();
+            
+            assert(rescued_obj->klass()->new_version() != NULL, "just checking");
+            
+            if (rescued_obj->klass()->new_version()->update_information() != NULL) {
+                MarkSweep::update_fields(rescued_obj, new_obj);
+                            } else {
+                rescued_obj->set_klass(rescued_obj->klass()->new_version());
+                Copy::aligned_disjoint_words((HeapWord*) rescued_obj, (HeapWord*) new_obj, size);
+                            }
+            
+            FREE_RESOURCE_ARRAY(HeapWord, rescued_ptr, size);
+            
+            new_obj->init_mark();
+            assert(new_obj->is_oop(), "must be a valid oop");
+                    }
+        _rescued_oops->clear();
+        _rescued_oops = NULL;
+            }
+}
+
+// (DCEVM) Update instances of a class whose fields changed.
+void MarkSweep::update_fields(oop q, oop new_location) {
+    
+    assert(q->klass()->new_version() != NULL, "class of old object must have new version");
+    
+    Klass* old_klass_oop = q->klass();
+    Klass* new_klass_oop = q->klass()->new_version();
+    
+    InstanceKlass *old_klass = InstanceKlass::cast(old_klass_oop);
+    InstanceKlass *new_klass = InstanceKlass::cast(new_klass_oop);
+    
+    int size = q->size_given_klass(old_klass);
+    int new_size = q->size_given_klass(new_klass);
+    
+    HeapWord* tmp = NULL;
+    oop tmp_obj = q;
+    
+    // Save object somewhere, there is an overlap in fields
+    if (new_klass_oop->is_copying_backwards()) {
+        if (((HeapWord *) q >= (HeapWord *) new_location && (HeapWord *) q < (HeapWord *) new_location + new_size) ||
+                ((HeapWord *) new_location >= (HeapWord *) q && (HeapWord *) new_location < (HeapWord *) q + size)) {
+            tmp = NEW_RESOURCE_ARRAY(HeapWord, size);
+            q = (oop) tmp;
+            Copy::aligned_disjoint_words((HeapWord*) q, (HeapWord*) tmp_obj, size);
+                    }
+            }
+    
+    q->set_klass(new_klass_oop);
+    int *cur = new_klass_oop->update_information();
+    assert(cur != NULL, "just checking");
+    MarkSweep::update_fields(new_location, q, cur);
+    
+    if (tmp != NULL) {
+        FREE_RESOURCE_ARRAY(HeapWord, tmp, size);
+            }
+}
+
+void MarkSweep::update_fields(oop new_location, oop tmp_obj, int *cur) {
+    assert(cur != NULL, "just checking");
+    char* to = (char*) (HeapWord*) new_location;
+    while (*cur != 0) {
+        int size = *cur;
+        if (size > 0) {
+            cur++;
+            int offset = *cur;
+            HeapWord* from = (HeapWord*) (((char *) (HeapWord*) tmp_obj) + offset);
+            if (size == HeapWordSize) {
+                 *((HeapWord*) to) = *from;
+                            } else if (size == HeapWordSize * 2) {
+                 *((HeapWord*) to) = *from;
+                 *(((HeapWord*) to) + 1) = *(from + 1);
+                            } else {
+                Copy::conjoint_jbytes(from, to, size);
+                            }
+            to += size;
+            cur++;
+                    } else {
+            assert(size < 0, "");
+            int skip = -*cur;
+            Copy::fill_to_bytes(to, skip, 0);
+            to += skip;
+            cur++;
+                    }
+            }
+}
+
+
+
 inline void MarkSweep::mark_object(oop obj) {
 #if INCLUDE_ALL_GCS
   if (G1StringDedup::is_enabled()) {
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/gc/serial/markSweep.hpp
--- a/src/share/vm/gc/serial/markSweep.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/gc/serial/markSweep.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -96,6 +96,7 @@
   friend class AdjustPointerClosure;
   friend class KeepAliveClosure;
   friend class VM_MarkSweep;
+  friend class GenMarkSweep;
   friend void marksweep_init();
 
   //
@@ -135,6 +136,8 @@
   static AdjustPointerClosure adjust_pointer_closure;
   static CLDToOopClosure      adjust_cld_closure;
 
+  static GrowableArray<HeapWord*>* _rescued_oops;
+
   // Accessors
   static uint total_invocations() { return _total_invocations; }
 
@@ -166,6 +169,10 @@
   // Check mark and maybe push on marking stack
   template <class T> static void mark_and_push(T* p);
 
+  static void copy_rescued_objects_back();
+    static void update_fields(oop q, oop new_location);
+    static void update_fields(oop new_location, oop tmp_obj, int *cur);
+
  private:
   // Call backs for marking
   static void mark_object(oop obj);
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/gc/shared/genCollectedHeap.hpp
--- a/src/share/vm/gc/shared/genCollectedHeap.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/gc/shared/genCollectedHeap.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -509,11 +509,10 @@
   // Save the tops of the spaces in all generations
   void record_gen_tops_before_GC() PRODUCT_RETURN;
 
-protected:
+public:
   void gc_prologue(bool full);
   void gc_epilogue(bool full);
 
-public:
   void stop();
 };
 
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/gc/shared/space.cpp
--- a/src/share/vm/gc/shared/space.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/gc/shared/space.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -367,30 +367,34 @@
   _compaction_top = bottom();
 }
 
+// (DCEVM) Calculates the compact_top that will be used for placing the next object with the giving size on the heap.
+HeapWord* CompactibleSpace::forward_compact_top(size_t size, CompactPoint* cp, HeapWord* compact_top) {
+    // First check if we should switch compaction space
+    assert(this == cp->space, "'this' should be current compaction space.");
+    size_t compaction_max_size = pointer_delta(end(), compact_top);
+    while (size > compaction_max_size) {
+        // switch to next compaction space
+        cp->space->set_compaction_top(compact_top);
+        cp->space = cp->space->next_compaction_space();
+        if (cp->space == NULL) {
+            cp->gen = GenCollectedHeap::heap()->young_gen();
+            assert(cp->gen != NULL, "compaction must succeed");
+            cp->space = cp->gen->first_compaction_space();
+            assert(cp->space != NULL, "generation must have a first compaction space");
+        }
+        compact_top = cp->space->bottom();
+        cp->space->set_compaction_top(compact_top);
+        cp->threshold = cp->space->initialize_threshold();
+        compaction_max_size = pointer_delta(cp->space->end(), compact_top);
+    }
+    return compact_top;
+}
+
 HeapWord* CompactibleSpace::forward(oop q, size_t size,
                                     CompactPoint* cp, HeapWord* compact_top) {
-  // q is alive
-  // First check if we should switch compaction space
-  assert(this == cp->space, "'this' should be current compaction space.");
-  size_t compaction_max_size = pointer_delta(end(), compact_top);
-  while (size > compaction_max_size) {
-    // switch to next compaction space
-    cp->space->set_compaction_top(compact_top);
-    cp->space = cp->space->next_compaction_space();
-    if (cp->space == NULL) {
-      cp->gen = GenCollectedHeap::heap()->young_gen();
-      assert(cp->gen != NULL, "compaction must succeed");
-      cp->space = cp->gen->first_compaction_space();
-      assert(cp->space != NULL, "generation must have a first compaction space");
-    }
-    compact_top = cp->space->bottom();
-    cp->space->set_compaction_top(compact_top);
-    cp->threshold = cp->space->initialize_threshold();
-    compaction_max_size = pointer_delta(cp->space->end(), compact_top);
-  }
-
+  compact_top = forward_compact_top(size, cp, compact_top);
   // store the forwarding pointer into the mark word
-  if ((HeapWord*)q != compact_top) {
+  if ((HeapWord*)q != compact_top || (size_t)q->size() != size) {
     q->forward_to(oop(compact_top));
     assert(q->is_gc_marked(), "encoding the pointer should preserve the mark");
   } else {
@@ -411,8 +415,66 @@
   return compact_top;
 }
 
+// Compute the forward sizes and leave out objects whose position could
+// possibly overlap other objects.
+HeapWord* CompactibleSpace::forward_with_rescue(HeapWord* q, size_t size,
+        CompactPoint* cp, HeapWord* compact_top) {
+    size_t forward_size = size;
+    
+    // (DCEVM) There is a new version of the class of q => different size
+     if (oop(q)->klass()->new_version() != NULL && oop(q)->klass()->new_version()->update_information() != NULL) {
+        
+        size_t new_size = oop(q)->size_given_klass(oop(q)->klass()->new_version());
+        assert(size != new_size, "instances without changed size have to be updated prior to GC run");
+        forward_size = new_size;
+            }
+    
+    compact_top = forward_compact_top(forward_size, cp, compact_top);
+    
+    if (must_rescue(oop(q), oop(compact_top))) {
+        if (MarkSweep::_rescued_oops == NULL) {
+            MarkSweep::_rescued_oops = new GrowableArray<HeapWord*>(128);
+                    }
+        MarkSweep::_rescued_oops->append(q);
+        return compact_top;
+            }
+    
+     return forward(oop(q), forward_size, cp, compact_top);
+}
+
+// Compute the forwarding addresses for the objects that need to be rescued.
+ HeapWord* CompactibleSpace::forward_rescued(CompactPoint* cp, HeapWord* compact_top) {
+    // TODO: empty the _rescued_oops after ALL spaces are compacted!
+    if (MarkSweep::_rescued_oops != NULL) {
+        for (int i = 0; i < MarkSweep::_rescued_oops->length(); i++) {
+            HeapWord* q = MarkSweep::_rescued_oops->at(i);
+            
+             /* size_t size = oop(q)->size();  changing this for cms for perm gen */
+             size_t size = block_size(q);
+            
+            // (DCEVM) There is a new version of the class of q => different size
+             if (oop(q)->klass()->new_version() != NULL) {
+                size_t new_size = oop(q)->size_given_klass(oop(q)->klass()->new_version());
+                assert(size != new_size, "instances without changed size have to be updated prior to GC run");
+                size = new_size;
+                            }
+            
+             compact_top = cp->space->forward(oop(q), size, cp, compact_top);
+            assert(compact_top <= end(), "must not write over end of space!");
+                    }
+        MarkSweep::_rescued_oops->clear();
+        MarkSweep::_rescued_oops = NULL;
+            }
+    return compact_top;
+}
+
 void ContiguousSpace::prepare_for_compaction(CompactPoint* cp) {
-  scan_and_forward(this, cp);
+  if (!Universe::is_redefining_gc_run()) {
+      scan_and_forward(this, cp, false);
+            } else {
+        // Redefinition run
+         scan_and_forward(this, cp, true);
+            }
 }
 
 void CompactibleSpace::adjust_pointers() {
@@ -424,8 +486,124 @@
   scan_and_adjust_pointers(this);
 }
 
+
+#ifdef ASSERT
+
+int CompactibleSpace::space_index(oop obj) {
+    GenCollectedHeap* heap = GenCollectedHeap::heap();
+    
+     //if (heap->is_in_permanent(obj)) {
+     //  return -1;
+     //}
+    
+     int index = 0;
+     Generation* generations[2] = {heap->old_gen(), heap->young_gen()};
+    for (int i = 1; i >= 0; i--) {
+        Generation* gen = generations[i];
+        CompactibleSpace* space = gen->first_compaction_space();
+         while (space != NULL) {
+            if (space->is_in_reserved(obj)) {
+                return index;
+                            }
+            space = space->next_compaction_space();
+            index++;
+                    }
+            }
+    
+     tty->print_cr("could not compute space_index for %08xh", (HeapWord*) obj);
+    index = 0;
+    for (int i = 1; i >= 0; i--) {
+        Generation* gen = generations[i];
+        tty->print_cr("  generation %s: %08xh - %08xh", gen->name(), gen->reserved().start(), gen->reserved().end());
+        
+         CompactibleSpace* space = gen->first_compaction_space();
+        while (space != NULL) {
+            tty->print_cr("    %2d space %08xh - %08xh", index, space->bottom(), space->end());
+            space = space->next_compaction_space();
+            index++;
+                    }
+            }
+    
+     ShouldNotReachHere();
+    return 0;
+    
+}
+
+#endif
+
+bool CompactibleSpace::must_rescue(oop old_obj, oop new_obj) {
+    // Only redefined objects can have the need to be rescued.
+     if (oop(old_obj)->klass()->new_version() == NULL) return false;
+    
+     //if (old_obj->is_perm()) {
+     //  // This object is in perm gen: Always rescue to satisfy invariant obj->klass() <= obj.
+     //  return true;
+     //}
+    
+     int new_size = old_obj->size_given_klass(oop(old_obj)->klass()->new_version());
+    int original_size = old_obj->size();
+    
+     Generation* tenured_gen = GenCollectedHeap::heap()->old_gen();
+    bool old_in_tenured = tenured_gen->is_in_reserved(old_obj);
+    bool new_in_tenured = tenured_gen->is_in_reserved(new_obj);
+    if (old_in_tenured == new_in_tenured) {
+        // Rescue if object may overlap with a higher memory address.
+         bool overlap = ((HeapWord*) old_obj + original_size < (HeapWord*) new_obj + new_size);
+        if (old_in_tenured) {
+            // Old and new address are in same space, so just compare the address.
+             // Must rescue if object moves towards the top of the space.
+             assert(space_index(old_obj) == space_index(new_obj), "old_obj and new_obj must be in same space");
+                    } else {
+            // In the new generation, eden is located before the from space, so a
+             // simple pointer comparison is sufficient.
+             assert(GenCollectedHeap::heap()->young_gen()->is_in_reserved(old_obj), "old_obj must be in DefNewGeneration");
+            assert(GenCollectedHeap::heap()->young_gen()->is_in_reserved(new_obj), "new_obj must be in DefNewGeneration");
+            assert(overlap == (space_index(old_obj) < space_index(new_obj)), "slow and fast computation must yield same result");
+                    }
+        return overlap;
+        
+           } else {
+        assert(space_index(old_obj) != space_index(new_obj), "old_obj and new_obj must be in different spaces");
+        if (tenured_gen->is_in_reserved(new_obj)) {
+            // Must never rescue when moving from the new into the old generation.
+            assert(GenCollectedHeap::heap()->young_gen()->is_in_reserved(old_obj), "old_obj must be in DefNewGeneration");
+            assert(space_index(old_obj) > space_index(new_obj), "must be");
+            return false;
+            
+                    } else /* if (tenured_gen->is_in_reserved(old_obj)) */ {
+            // Must always rescue when moving from the old into the new generation.
+             assert(GenCollectedHeap::heap()->young_gen()->is_in_reserved(new_obj), "new_obj must be in DefNewGeneration");
+            assert(space_index(old_obj) < space_index(new_obj), "must be");
+            return true;
+                    }
+            }
+   
+}
+
+HeapWord* CompactibleSpace::rescue(HeapWord* old_obj) {
+    assert(must_rescue(oop(old_obj), oop(old_obj)->forwardee()), "do not call otherwise");
+    
+     int size = oop(old_obj)->size();
+    HeapWord* rescued_obj = NEW_RESOURCE_ARRAY(HeapWord, size);
+    Copy::aligned_disjoint_words(old_obj, rescued_obj, size);
+    
+    if (MarkSweep::_rescued_oops == NULL) {
+        MarkSweep::_rescued_oops = new GrowableArray<HeapWord*>(128);
+            }
+    
+    MarkSweep::_rescued_oops->append(rescued_obj);
+    return rescued_obj;
+    
+}
+
 void CompactibleSpace::compact() {
-  scan_and_compact(this);
+  
+  if (!Universe::is_redefining_gc_run()) {
+        scan_and_compact(this, false);
+            } else {
+        // Redefinition run
+        scan_and_compact(this, true);
+                    }
 }
 
 void Space::print_short() const { print_short_on(tty); }
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/gc/shared/space.hpp
--- a/src/share/vm/gc/shared/space.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/gc/shared/space.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -413,6 +413,9 @@
   // indicates when the next such action should be taken.
   virtual void prepare_for_compaction(CompactPoint* cp) = 0;
   // MarkSweep support phase3
+  DEBUG_ONLY(int space_index(oop obj));
+  static bool must_rescue(oop old_obj, oop new_obj);
+  static HeapWord* rescue(HeapWord* old_obj);
   virtual void adjust_pointers();
   // MarkSweep support phase4
   virtual void compact();
@@ -443,6 +446,15 @@
   virtual HeapWord* forward(oop q, size_t size, CompactPoint* cp,
                     HeapWord* compact_top);
 
+  // (DCEVM) same as forwad, but can rescue objects. Invoked only during
+     // redefinition runs
+     HeapWord* forward_with_rescue(HeapWord* q, size_t size, CompactPoint* cp,
+            HeapWord* compact_top);
+     HeapWord* forward_rescued(CompactPoint* cp, HeapWord* compact_top);
+    
+    // (tw) Compute new compact top without actually forwarding the object.
+  virtual HeapWord* forward_compact_top(size_t size, CompactPoint* cp, HeapWord* compact_top);
+    
   // Return a size with adjustments as required of the space.
   virtual size_t adjust_object_size_v(size_t size) const { return size; }
 
@@ -473,12 +485,12 @@
 
   // Frequently calls obj_size().
   template <class SpaceType>
-  static inline void scan_and_compact(SpaceType* space);
+  static inline void scan_and_compact(SpaceType* space, bool redefinition_run);
 
   // Frequently calls scanned_block_is_obj() and scanned_block_size().
   // Requires the scan_limit() function.
   template <class SpaceType>
-  static inline void scan_and_forward(SpaceType* space, CompactPoint* cp);
+  static inline void scan_and_forward(SpaceType* space, CompactPoint* cp, bool redefinition_run);
 };
 
 class GenSpaceMangler;
@@ -489,7 +501,7 @@
   friend class VMStructs;
   // Allow scan_and_forward function to call (private) overrides for auxiliary functions on this class
   template <typename SpaceType>
-  friend void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp);
+  friend void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp, bool redefinition_run);
 
  private:
   // Auxiliary functions for scan_and_forward support.
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/gc/shared/space.inline.hpp
--- a/src/share/vm/gc/shared/space.inline.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/gc/shared/space.inline.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -128,7 +128,7 @@
 };
 
 template <class SpaceType>
-inline void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp) {
+inline void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp, bool redefinition_run) {
   // Compute the new addresses for the live objects and store it in the mark
   // Used by universe::mark_sweep_phase2()
 
@@ -166,7 +166,17 @@
       // prefetch beyond cur_obj
       Prefetch::write(cur_obj, interval);
       size_t size = space->scanned_block_size(cur_obj);
+      if (redefinition_run) {
+ compact_top = cp->space->forward_with_rescue(cur_obj, size, 
+ cp, compact_top);
+  if (cur_obj < first_dead && oop(cur_obj)->is_gc_marked()) {
+ /* Was moved (otherwise, forward would reset mark),                
+             set first_dead to here */ 
+ first_dead = cur_obj;
+                 }
+             } else {              
       compact_top = cp->space->forward(oop(cur_obj), size, cp, compact_top);
+                }
       cur_obj += size;
       end_of_live = cur_obj;
     } else {
@@ -186,7 +196,7 @@
         end_of_live = end;
       } else {
         // otherwise, it really is a free region.
-
+          
         // cur_obj is a pointer to a dead object. Use this dead memory to store a pointer to the next live object.
         *(HeapWord**)cur_obj = end;
 
@@ -201,6 +211,9 @@
     }
   }
 
+  if (redefinition_run) {
+        compact_top = space->forward_rescued(cp, compact_top); 
+  }
   assert(cur_obj == scan_limit, "just checking");
   space->_end_of_live = end_of_live;
   if (first_dead != NULL) {
@@ -287,13 +300,13 @@
 }
 
 template <class SpaceType>
-inline void CompactibleSpace::scan_and_compact(SpaceType* space) {
+inline void CompactibleSpace::scan_and_compact(SpaceType* space, bool redefinition_run) {
   // Copy all live objects to their new location
   // Used by MarkSweep::mark_sweep_phase4()
 
   verify_up_to_first_dead(space);
 
-  HeapWord* const bottom = space->bottom();
+  HeapWord* bottom = space->bottom();
   HeapWord* const end_of_live = space->_end_of_live;
 
   assert(space->_first_dead <= end_of_live, "Invariant. _first_dead: " PTR_FORMAT " <= end_of_live: " PTR_FORMAT, p2i(space->_first_dead), p2i(end_of_live));
@@ -302,6 +315,7 @@
     clear_empty_region(space);
     return;
   }
+  //todo: czy tu trzeba dorzucic zmiane end_of_live (q = _first_dead z patcha)?
 
   const intx scan_interval = PrefetchScanIntervalInBytes;
   const intx copy_interval = PrefetchCopyIntervalInBytes;
@@ -329,11 +343,33 @@
       size_t size = space->obj_size(cur_obj);
       HeapWord* compaction_top = (HeapWord*)oop(cur_obj)->forwardee();
 
+      if (redefinition_run && space->must_rescue(oop(bottom), oop(bottom)->forwardee())) {       
+          space->rescue(bottom);
+            debug_only(Copy::fill_to_words(bottom, size, 0));
+            bottom += size;
+            continue;
+        }   
+              
       // prefetch beyond compaction_top
       Prefetch::write(compaction_top, copy_interval);
 
       // copy object and reinit its mark
-      assert(cur_obj != compaction_top, "everything in this pass should be moving");
+      assert(bottom != compaction_top || oop(bottom)->klass()->new_version() != NULL, "everything in this pass should be moving");
+            
+ if (redefinition_run && oop(bottom)->klass()->new_version() != NULL) {
+  Klass* new_version = oop(bottom)->klass()->new_version();
+  if (new_version->update_information() == NULL) {
+  Copy::aligned_conjoint_words(bottom, compaction_top, size);
+  oop(compaction_top)->set_klass(new_version);
+                 } else {
+  MarkSweep::update_fields(oop(bottom), oop(compaction_top));
+                 }
+  oop(compaction_top)->init_mark();
+  assert(oop(compaction_top)->klass() != NULL, "should have a class");
+  debug_only(prev_obj = bottom);
+  bottom += size;
+ continue;
+            }   
       Copy::aligned_conjoint_words(cur_obj, compaction_top, size);
       oop(compaction_top)->init_mark();
       assert(oop(compaction_top)->klass() != NULL, "should have a class");
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/interpreter/linkResolver.cpp
--- a/src/share/vm/interpreter/linkResolver.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/interpreter/linkResolver.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -275,7 +275,7 @@
 
 void LinkResolver::check_klass_accessability(KlassHandle ref_klass, KlassHandle sel_klass, TRAPS) {
   Reflection::VerifyClassAccessResults vca_result =
-    Reflection::verify_class_access(ref_klass(), sel_klass(), true);
+    Reflection::verify_class_access(ref_klass()->newest_version(), sel_klass()->newest_version(), true);
   if (vca_result != Reflection::ACCESS_OK) {
     ResourceMark rm(THREAD);
     char* msg = Reflection::verify_class_access_msg(ref_klass(), sel_klass(), vca_result);
@@ -545,7 +545,7 @@
   // We'll check for the method name first, as that's most likely
   // to be false (so we'll short-circuit out of these tests).
   if (sel_method->name() == vmSymbols::clone_name() &&
-      sel_klass() == SystemDictionary::Object_klass() &&
+      sel_klass()->newest_version() == SystemDictionary::Object_klass()->newest_version() &&
       resolved_klass->is_array_klass()) {
     // We need to change "protected" to "public".
     assert(flags.is_protected(), "clone not protected?");
@@ -952,7 +952,7 @@
     ResourceMark rm(THREAD);
     stringStream ss;
 
-    if (sel_klass() != current_klass()) {
+    if (sel_klass() != current_klass() && sel_klass() != current_klass()->active_version()) {
       ss.print("Update to %s final field %s.%s attempted from a different class (%s) than the field's declaring class",
                 is_static ? "static" : "non-static", resolved_klass()->external_name(), fd.name()->as_C_string(),
                 current_klass()->external_name());
@@ -1337,6 +1337,8 @@
       assert(resolved_method->can_be_statically_bound(), "cannot override this method");
       selected_method = resolved_method;
     } else {
+      // (DCEVM) Check that the receiver is a subtype of the holder of the resolved method.
+      assert(inst->is_subtype_of(resolved_method->method_holder()), "receiver and resolved method holder are inconsistent");
       selected_method = methodHandle(THREAD, recv_klass->method_at_vtable(vtable_index));
     }
   }
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/memory/universe.cpp
--- a/src/share/vm/memory/universe.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/memory/universe.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -88,6 +88,8 @@
 #include "classfile/sharedClassUtil.hpp"
 #endif
 
+bool Universe::_is_redefining_gc_run = false;
+
 // Known objects
 Klass* Universe::_boolArrayKlassObj                 = NULL;
 Klass* Universe::_byteArrayKlassObj                 = NULL;
@@ -179,6 +181,43 @@
   f(doubleArrayKlassObj());
 }
 
+// (DCEVM) This method should iterate all pointers that are not within heap objects.
+void Universe::root_oops_do(OopClosure *oopClosure) {
+
+  class AlwaysTrueClosure: public BoolObjectClosure {
+  public:
+    void do_object(oop p) { ShouldNotReachHere(); }
+    bool do_object_b(oop p) { return true; }
+  };
+  AlwaysTrueClosure always_true;
+
+  Universe::oops_do(oopClosure);
+//  ReferenceProcessor::oops_do(oopClosure); (tw) check why no longer there
+  JNIHandles::oops_do(oopClosure);   // Global (strong) JNI handles
+  Threads::oops_do(oopClosure, NULL);
+  ObjectSynchronizer::oops_do(oopClosure);
+  FlatProfiler::oops_do(oopClosure);
+  JvmtiExport::oops_do(oopClosure);
+
+  // Now adjust pointers in remaining weak roots.  (All of which should
+  // have been cleared if they pointed to non-surviving objects.)
+  // Global (weak) JNI handles
+  JNIHandles::weak_oops_do(&always_true, oopClosure);
+
+  CodeBlobToOopClosure blobClosure(oopClosure, CodeBlobToOopClosure::FixRelocations);
+  CodeCache::blobs_do(&blobClosure);
+  StringTable::oops_do(oopClosure);
+  
+  // (DCEVM) TODO: Check if this is correct?
+  //CodeCache::scavenge_root_nmethods_oops_do(oopClosure);
+  //Management::oops_do(oopClosure);
+  //ref_processor()->weak_oops_do(&oopClosure);
+  //PSScavenge::reference_processor()->weak_oops_do(&oopClosure);
+
+  // SO_AllClasses
+  SystemDictionary::oops_do(oopClosure);
+}
+
 void Universe::oops_do(OopClosure* f, bool do_all) {
 
   f->do_oop((oop*) &_int_mirror);
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/memory/universe.hpp
--- a/src/share/vm/memory/universe.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/memory/universe.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -127,6 +127,8 @@
 
   static Klass* _objectArrayKlassObj;
 
+  static bool _is_redefining_gc_run;
+
   // Known objects in the VM
 
   // Primitive objects
@@ -269,6 +271,15 @@
   static void compute_verify_oop_data();
 
  public:
+
+    static bool is_redefining_gc_run() {
+        return _is_redefining_gc_run;
+    }
+
+    static void set_redefining_gc_run(bool b) {
+        _is_redefining_gc_run = b;
+    }
+    
   // Known classes in the VM
   static Klass* boolArrayKlassObj()                 { return _boolArrayKlassObj;   }
   static Klass* byteArrayKlassObj()                 { return _byteArrayKlassObj;   }
@@ -468,6 +479,7 @@
   static void run_finalizers_on_exit();
 
   // Iteration
+  static void root_oops_do(OopClosure *f);
 
   // Apply "f" to the addresses of all the direct heap pointers maintained
   // as static fields of "Universe".
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/oops/cpCache.cpp
--- a/src/share/vm/oops/cpCache.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/oops/cpCache.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -348,7 +348,8 @@
   if (has_appendix) {
     const int appendix_index = f2_as_index() + _indy_resolved_references_appendix_offset;
     assert(appendix_index >= 0 && appendix_index < resolved_references->length(), "oob");
-    assert(resolved_references->obj_at(appendix_index) == NULL, "init just once");
+    // FIXME (DCEVM) relaxing for now...
+    //assert(resolved_references->obj_at(appendix_index) == NULL, "init just once");
     resolved_references->obj_at_put(appendix_index, appendix());
   }
 
@@ -356,7 +357,8 @@
   if (has_method_type) {
     const int method_type_index = f2_as_index() + _indy_resolved_references_method_type_offset;
     assert(method_type_index >= 0 && method_type_index < resolved_references->length(), "oob");
-    assert(resolved_references->obj_at(method_type_index) == NULL, "init just once");
+    // FIXME (DCEVM) relaxing for now...
+    //assert(resolved_references->obj_at(method_type_index) == NULL, "init just once");
     resolved_references->obj_at_put(method_type_index, method_type());
   }
 
@@ -533,6 +535,22 @@
   // the method is in the interesting class so the entry is interesting
   return m;
 }
+
+// Enhanced RedefineClasses() API support (DCEVM):
+// Clear cached entry, let it be re-resolved
+void ConstantPoolCacheEntry::clear_entry() {
+  _indices = constant_pool_index();
+  _f1 = NULL;
+  if (!is_resolved_reference()) {
+    _f2 = 0;
+  }
+  // FIXME: (DCEVM) we want to clear flags, but parameter size is actually used
+  // after we return from the method, before entry is re-initialized. So let's
+  // keep parameter size the same.
+  // For example, it's used in TemplateInterpreterGenerator::generate_return_entry_for
+  // Also, we need to keep flag marking entry as one containing resolved_reference
+  _flags &= parameter_size_mask | (1 << is_resolved_ref_shift);
+}
 #endif // INCLUDE_JVMTI
 
 void ConstantPoolCacheEntry::print(outputStream* st, int index) const {
@@ -646,6 +664,14 @@
     }
   }
 }
+
+// Enhanced RedefineClasses() API support (DCEVM):
+// Clear all entries
+void ConstantPoolCache::clear_entries() {
+  for (int i = 0; i < length(); i++) {
+    entry_at(i)->clear_entry();
+  }
+}
 #endif // INCLUDE_JVMTI
 
 
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/oops/cpCache.hpp
--- a/src/share/vm/oops/cpCache.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/oops/cpCache.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -180,6 +180,8 @@
     tos_state_bits             = 4,
     tos_state_mask             = right_n_bits(tos_state_bits),
     tos_state_shift            = BitsPerInt - tos_state_bits,  // see verify_tos_state_shift below
+    // (DCEVM) We need to remember entries which has resolved reference indices as we don't want to clean them
+    is_resolved_ref_shift      = 27,
     // misc. option bits; can be any bit position in [16..27]
     is_field_entry_shift       = 26,  // (F) is it a field or a method?
     has_method_type_shift      = 25,  // (M) does the call site have a MethodType?
@@ -212,6 +214,7 @@
   void initialize_resolved_reference_index(int ref_index) {
     assert(_f2 == 0, "set once");  // note: ref_index might be zero also
     _f2 = ref_index;
+    _flags = 1 << is_resolved_ref_shift;
   }
 
   void set_field(                                // sets entry to resolved field state
@@ -351,6 +354,7 @@
   bool is_final() const                          { return (_flags & (1 << is_final_shift))          != 0; }
   bool is_forced_virtual() const                 { return (_flags & (1 << is_forced_virtual_shift)) != 0; }
   bool is_vfinal() const                         { return (_flags & (1 << is_vfinal_shift))         != 0; }
+  bool is_resolved_reference() const             { return (_flags & (1 << is_resolved_ref_shift))   != 0; }
   bool has_appendix() const                      { return (!is_f1_null()) && (_flags & (1 << has_appendix_shift))      != 0; }
   bool has_method_type() const                   { return (!is_f1_null()) && (_flags & (1 << has_method_type_shift))   != 0; }
   bool is_method_entry() const                   { return (_flags & (1 << is_field_entry_shift))    == 0; }
@@ -381,6 +385,10 @@
          bool* trace_name_printed);
   bool check_no_old_or_obsolete_entries();
   Method* get_interesting_method_entry(Klass* k);
+
+  // Enhanced RedefineClasses() API support (DCEVM):
+  // Clear cached entry, let it be re-resolved
+  void clear_entry();
 #endif // INCLUDE_JVMTI
 
   // Debugging & Printing
@@ -479,6 +487,10 @@
   void adjust_method_entries(InstanceKlass* holder, bool* trace_name_printed);
   bool check_no_old_or_obsolete_entries();
   void dump_cache();
+
+  // Enhanced RedefineClasses() API support (DCEVM):
+  // Clear all entries
+  void clear_entries();
 #endif // INCLUDE_JVMTI
 
   // Deallocate - no fields to deallocate
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/oops/instanceKlass.cpp
--- a/src/share/vm/oops/instanceKlass.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/oops/instanceKlass.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -640,7 +640,8 @@
       }
 #endif
       this_k->set_init_state(linked);
-      if (JvmtiExport::should_post_class_prepare()) {
+      // (DCEVM) Must check for old version in order to prevent infinite loops.
+      if (JvmtiExport::should_post_class_prepare() && this_k->old_version() == NULL /* JVMTI deadlock otherwise */) {
         Thread *thread = THREAD;
         assert(thread->is_Java_thread(), "thread->is_Java_thread()");
         JvmtiExport::post_class_prepare((JavaThread *) thread, this_k());
@@ -720,7 +721,9 @@
     // If we were to use wait() instead of waitInterruptibly() then
     // we might end up throwing IE from link/symbol resolution sites
     // that aren't expected to throw.  This would wreak havoc.  See 6320309.
-    while(this_k->is_being_initialized() && !this_k->is_reentrant_initialization(self)) {
+    // (DCEVM) Wait also for the old class version to be fully initialized.
+    while((this_k->is_being_initialized() && !this_k->is_reentrant_initialization(self))
+            || (this_k->old_version() != NULL && InstanceKlass::cast(this_k->old_version())->is_being_initialized())) {
         wait = true;
       ol.waitUninterruptibly(CHECK);
     }
@@ -973,6 +976,18 @@
   return false;
 }
 
+bool InstanceKlass::implements_interface_any_version(Klass* k) const {
+  k = k->newest_version();
+  if (this->newest_version() == k) return true;
+  assert(k->is_interface(), "should be an interface class");
+  for (int i = 0; i < transitive_interfaces()->length(); i++) {
+    if (transitive_interfaces()->at(i)->newest_version() == k) {
+      return true;
+    }
+  }
+  return false;
+}
+
 bool InstanceKlass::is_same_or_direct_interface(Klass *k) const {
   // Verify direct super interface
   if (this == k) return true;
@@ -1250,6 +1265,18 @@
   }
 }
 
+void InstanceKlass::store_update_information(GrowableArray<int> &values) {
+  int *arr = NEW_C_HEAP_ARRAY(int, values.length(), mtClass);
+  for (int i=0; i<values.length(); i++) {
+    arr[i] = values.at(i);
+  }
+  set_update_information(arr);
+}
+
+void InstanceKlass::clear_update_information() {
+  FREE_C_HEAP_ARRAY(update_information(), mtClass);
+  set_update_information(NULL);
+}
 
 void InstanceKlass::do_local_static_fields(FieldClosure* cl) {
   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
@@ -1860,6 +1887,18 @@
   return id;
 }
 
+bool InstanceKlass::update_jmethod_id(Method* method, jmethodID newMethodID) {
+  size_t idnum = (size_t)method->method_idnum();
+  jmethodID* jmeths = methods_jmethod_ids_acquire();
+  size_t length;                                // length assigned as debugging crumb
+  jmethodID id = NULL;
+  if (jmeths != NULL &&                         // If there is a cache
+      (length = (size_t)jmeths[0]) > idnum) {   // and if it is long enough,
+    jmeths[idnum+1] = newMethodID;              // Set method id (may be NULL)
+    return true;
+  }
+  return false;
+}
 
 // Common code to get the jmethodID cache length and the jmethodID
 // value at index idnum if there is one.
@@ -1908,6 +1947,12 @@
 
 void InstanceKlass::remove_dependent_nmethod(nmethod* nm, bool delete_immediately) {
   dependencies().remove_dependent_nmethod(nm, delete_immediately);
+  
+  // (DCEVM) Hack as dependencies get wrong version of Klass*
+    if (this->old_version() != NULL) {
+        InstanceKlass::cast(this->old_version())->remove_dependent_nmethod(nm, true);
+        return;
+}
 }
 
 #ifndef PRODUCT
@@ -2865,6 +2910,24 @@
   assert(is_klass(), "must be klass");
   Klass::print_on(st);
 
+  // (DCEVM) Output revision number and revision numbers of older / newer and oldest / newest version of this class.
+  if (AllowEnhancedClassRedefinition) {
+    st->print(BULLET"revision:          %d", revision_number());
+    if (new_version() != NULL) {
+      st->print(" (newer=%d)", new_version()->revision_number());
+    }
+    if (newest_version() != new_version() && newest_version() != this) {
+      st->print(" (newest=%d)", newest_version()->revision_number());
+    }
+    if (old_version() != NULL) {
+      st->print(" (old=%d)", old_version()->revision_number());
+    }
+    if (oldest_version() != old_version() && oldest_version() != this) {
+      st->print(" (oldest=%d)", oldest_version()->revision_number());
+    }
+    st->cr();
+  }
+
   st->print(BULLET"instance size:     %d", size_helper());                        st->cr();
   st->print(BULLET"klass size:        %d", size());                               st->cr();
   st->print(BULLET"access:            "); access_flags().print_on(st);            st->cr();
@@ -3275,7 +3338,7 @@
     }
 
     guarantee(sib->is_klass(), "should be klass");
-    guarantee(sib->super() == super, "siblings should have same superklass");
+    guarantee(sib->super() == super || super->newest_version() == SystemDictionary::Object_klass(), "siblings should have same superklass");
   }
 
   // Verify implementor fields
@@ -3467,6 +3530,7 @@
   if (previous_versions() == NULL) {
     return;
   }
+  // FIXME: (DCEVM) Should we purge something?
 
   // This klass has previous versions so see what we can cleanup
   // while it is safe to do so.
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/oops/instanceKlass.hpp
--- a/src/share/vm/oops/instanceKlass.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/oops/instanceKlass.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -119,6 +119,7 @@
   friend class JVMCIVMStructs;
   friend class ClassFileParser;
   friend class CompileReplay;
+  friend class VM_EnhancedRedefineClasses;
 
  protected:
   InstanceKlass(const ClassFileParser& parser, unsigned kind);
@@ -729,8 +730,16 @@
   }
 
   bool has_been_redefined() const {
-    return (_misc_flags & _misc_has_been_redefined) != 0;
+    return (_old_version != NULL) || ((_misc_flags & _misc_has_been_redefined) != 0);
   }
+  
+  void set_old_version(Klass* klass) {
+      Klass::set_old_version(klass);
+      if (klass != NULL) {
+          _has_previous_versions = true;
+      }
+  }
+  
   void set_has_been_redefined() {
     _misc_flags |= _misc_has_been_redefined;
   }
@@ -893,6 +902,7 @@
                 size_t *length_p, jmethodID* id_p);
   void ensure_space_for_methodids(int start_offset = 0);
   jmethodID jmethod_id_or_null(Method* method);
+  bool update_jmethod_id(Method* method, jmethodID newMethodID);
 
   // annotations support
   Annotations* annotations() const          { return _annotations; }
@@ -966,6 +976,7 @@
   // subclass/subinterface checks
   bool implements_interface(Klass* k) const;
   bool is_same_or_direct_interface(Klass* k) const;
+  bool implements_interface_any_version(Klass* k) const;
 
 #ifdef ASSERT
   // check whether this class or one of its superclasses was redefined
@@ -1024,6 +1035,10 @@
   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
 
+  // (DCEVM) instance update information to be used in GC run
+  void store_update_information(GrowableArray<int> &values);
+  void clear_update_information();
+
   void methods_do(void f(Method* method));
   void array_klasses_do(void f(Klass* k));
   void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/oops/klass.cpp
--- a/src/share/vm/oops/klass.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/oops/klass.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -178,6 +178,12 @@
 
   _primary_supers[0] = this;
   set_super_check_offset(in_bytes(primary_supers_offset()));
+  set_redefinition_flags(Klass::NoRedefinition);
+    set_redefining(false);
+    set_new_version(NULL);
+    set_old_version(NULL);
+    set_redefinition_index(-1);
+    set_revision_number(-1);
 }
 
 jint Klass::array_layout_helper(BasicType etype) {
@@ -368,6 +374,24 @@
   debug_only(verify();)
 }
 
+// (DCEVM)
+void Klass::remove_from_sibling_list() {
+  debug_only(verify();)
+  // remove ourselves to superklass' subklass list
+  InstanceKlass* super = superklass();
+  assert(super != NULL, "should have super");
+  if (super->subklass() == this) {
+    // first subklass
+    super->set_subklass(next_sibling());
+  } else {
+    Klass* sib = super->subklass();
+    while (sib->next_sibling() != this) {
+      sib = sib->next_sibling();
+    };
+    sib->set_next_sibling(next_sibling());
+  }
+}
+
 bool Klass::is_loader_alive(BoolObjectClosure* is_alive) {
 #ifdef ASSERT
   // The class is alive iff the class loader is alive.
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/oops/klass.hpp
--- a/src/share/vm/oops/klass.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/oops/klass.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -119,6 +119,10 @@
   oop       _java_mirror;
   // Superclass
   Klass*      _super;
+  // Old class
+  Klass*      _old_version;
+  // New class
+  Klass*      _new_version;
   // First subclass (NULL if none); _subklass->next_sibling() is next one
   Klass*      _subklass;
   // Sibling link (or NULL); links all subklasses of a klass
@@ -134,6 +138,16 @@
   jint        _modifier_flags;  // Processed access flags, for use by Class.getModifiers.
   AccessFlags _access_flags;    // Access flags. The class/interface distinction is stored here.
 
+  // (DCEVM) fields for enhanced class redefinition
+  jint        _revision_number;        // The revision number for redefined classes
+  jint        _redefinition_index;     // Index of this class when performing the redefinition
+  bool        _subtype_changed;
+  int         _redefinition_flags;     // Level of class redefinition
+  bool        _is_copying_backwards;   // Does the class need to copy fields backwards? => possibly overwrite itself?
+  bool        _original_field_offsets_changed; // Did the original field offsets of this class change during class redefinition?
+  int *       _update_information;     // Update information
+  bool        _is_redefining;
+
   TRACE_DEFINE_TRACE_ID_FIELD;
 
   // Biased locking implementation and statistics
@@ -196,6 +210,53 @@
   Array<Klass*>* secondary_supers() const { return _secondary_supers; }
   void set_secondary_supers(Array<Klass*>* k) { _secondary_supers = k; }
 
+  // BEGIN class redefinition utilities
+
+  // double links between new and old version of a class
+  Klass* old_version() const                           { return _old_version; }
+  virtual void set_old_version(Klass* klass)                   { assert(_old_version == NULL || klass == NULL, "Can only be set once!"); _old_version = klass; }
+  Klass* new_version() const                           { return _new_version; }
+  void set_new_version(Klass* klass)                 { assert(_new_version == NULL || klass == NULL, "Can only be set once!"); _new_version = klass; }
+
+  // A subtype of this class is no longer a subtype
+  bool has_subtype_changed() const                     { return _subtype_changed; }
+  void set_subtype_changed(bool b)                     { assert(is_newest_version() || new_version()->is_newest_version(), "must be newest or second newest version");
+                                                         _subtype_changed = b; }
+  // state of being redefined
+  int redefinition_index() const                       { return _redefinition_index; }
+  void set_redefinition_index(int index)               { _redefinition_index = index; }
+  void set_redefining(bool b)                          { _is_redefining = b; }
+  bool is_redefining() const                           { return _is_redefining; }
+  int redefinition_flags() const                       { return _redefinition_flags; }
+  bool check_redefinition_flag(int flags) const        { return (_redefinition_flags & flags) != 0; }
+  void set_redefinition_flags(int flags)               { _redefinition_flags = flags; }
+  void set_redefinition_flag(int flag)                 { _redefinition_flags |= flag; }
+  void clear_redefinition_flag(int flag)               { _redefinition_flags &= ~flag; }
+  bool is_copying_backwards() const                    { return _is_copying_backwards; }
+  void set_copying_backwards(bool b)                   { _is_copying_backwards = b; }
+
+  // update information
+  int *update_information() const                      { return _update_information; }
+  void set_update_information(int *info)               { _update_information = info; }
+
+  // Revision number for redefined classes, -1 for originally loaded classes
+  bool was_redefined() const            { return _revision_number != -1; }
+  jint revision_number() const          { return _revision_number; }
+  void set_revision_number(jint number) { _revision_number = number; }
+
+  const Klass* oldest_version() const   { return _old_version == NULL ? this : _old_version->oldest_version(); }
+        Klass* oldest_version()         { return _old_version == NULL ? this : _old_version->oldest_version(); }
+
+  const Klass* newest_version() const   { return _new_version == NULL ? this : _new_version->newest_version(); }
+        Klass* newest_version()         { return _new_version == NULL ? this : _new_version->newest_version(); }
+
+  const Klass* active_version() const   { return _new_version == NULL || _new_version->is_redefining() ? this : _new_version->active_version(); }
+        Klass* active_version()         { return _new_version == NULL || _new_version->is_redefining() ? this : _new_version->active_version(); }
+
+  bool is_newest_version() const        { return _new_version == NULL; }
+
+  // END class redefinition utilities
+
   // Return the element of the _super chain of the given depth.
   // If there is no such element, return either NULL or this.
   Klass* primary_super_of_depth(juint i) const {
@@ -249,6 +310,7 @@
   Klass* next_sibling() const          { return _next_sibling; }
   InstanceKlass* superklass() const;
   void append_to_sibling_list();           // add newly created receiver to superklass' subklass list
+  void remove_from_sibling_list();         // (DCEVM) remove receiver from sibling list
 
   void set_next_link(Klass* k) { _next_link = k; }
   Klass* next_link() const { return _next_link; }   // The next klass defined by the class loader.
@@ -285,6 +347,16 @@
   void     set_next_sibling(Klass* s);
 
  public:
+  // (DCEVM) Different class redefinition flags of code evolution.
+  enum RedefinitionFlags {
+    NoRedefinition,                             // This class is not redefined at all!
+    ModifyClass = 1,                            // There are changes to the class meta data.
+    ModifyClassSize = ModifyClass << 1,         // The size of the class meta data changes.
+    ModifyInstances = ModifyClassSize << 1,     // There are change to the instance format.
+    ModifyInstanceSize = ModifyInstances << 1,  // The size of instances changes.
+    RemoveSuperType = ModifyInstanceSize << 1,  // A super type of this class is removed.
+    MarkedAsAffected = RemoveSuperType << 1     // This class has been marked as an affected class.
+  };
 
   // Compiler support
   static ByteSize super_offset()                 { return in_ByteSize(offset_of(Klass, _super)); }
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/oops/klassVtable.cpp
--- a/src/share/vm/oops/klassVtable.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/oops/klassVtable.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -1497,6 +1497,8 @@
 
 void klassVtable::verify_against(outputStream* st, klassVtable* vt, int index) {
   vtableEntry* vte = &vt->table()[index];
+  // (DCEVM) FIXME-isd: do we need the following line?
+  if (vte->method() == NULL || table()[index].method() == NULL) return;
   if (vte->method()->name()      != table()[index].method()->name() ||
       vte->method()->signature() != table()[index].method()->signature()) {
     fatal("mismatched name/signature of vtable entries");
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/oops/method.cpp
--- a/src/share/vm/oops/method.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/oops/method.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -1398,6 +1398,8 @@
 
   // Reset correct method/const method, method size, and parameter info
   newm->set_constMethod(newcm);
+  newm->set_new_version(newm->new_version());
+  newm->set_old_version(newm->old_version());
   newm->constMethod()->set_code_size(new_code_length);
   newm->constMethod()->set_constMethod_size(new_const_method_size);
   assert(newm->code_size() == new_code_length, "check");
@@ -2087,6 +2089,10 @@
 
 // Add a method id to the jmethod_ids
 jmethodID Method::make_jmethod_id(ClassLoaderData* loader_data, Method* m) {
+  // FIXME: (DCEVM) ???
+  if (m != m->newest_version()) {
+    m = m->newest_version();
+  }
   ClassLoaderData* cld = loader_data;
 
   if (!SafepointSynchronize::is_at_safepoint()) {
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/oops/method.hpp
--- a/src/share/vm/oops/method.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/oops/method.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -70,6 +70,9 @@
   MethodCounters*   _method_counters;
   AccessFlags       _access_flags;               // Access flags
   int               _vtable_index;               // vtable index of this method (see VtableIndexFlag)
+  // (DCEVM) Newer version of method available?
+  Method*           _new_version;
+  Method*           _old_version;
                                                  // note: can have vtables with >2**16 elements (because of inheritance)
   u2                _intrinsic_id;               // vmSymbols::intrinsic_id (0 == _none)
 
@@ -151,6 +154,23 @@
   int name_index() const                         { return constMethod()->name_index();         }
   void set_name_index(int index)                 { constMethod()->set_name_index(index);       }
 
+  Method* new_version() const                    { return _new_version; }
+  void set_new_version(Method* m)                { _new_version = m; }
+  Method* newest_version()                       { return (_new_version == NULL) ? this : _new_version->newest_version(); }
+
+  Method* old_version() const                    { return _old_version; }
+  void set_old_version(Method* m) {
+    /*if (m == NULL) {
+      _old_version = NULL;
+      return;
+    }*/
+
+    assert(_old_version == NULL, "may only be set once");
+    assert(this->code_size() == m->code_size(), "must have same code length");
+    _old_version = m;
+  }
+  const Method* oldest_version() const           { return (_old_version == NULL) ? this : _old_version->oldest_version(); }
+
   // signature
   Symbol* signature() const                      { return constants()->symbol_at(signature_index()); }
   int signature_index() const                    { return constMethod()->signature_index();         }
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/prims/jni.cpp
--- a/src/share/vm/prims/jni.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/prims/jni.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -346,6 +346,7 @@
                                                    class_loader,
                                                    Handle(),
                                                    &st,
+                                                   KlassHandle(),
                                                    CHECK_NULL);
 
   if (log_is_enabled(Debug, class, resolve) && k != NULL) {
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/prims/jvm.cpp
--- a/src/share/vm/prims/jvm.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/prims/jvm.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -936,7 +936,7 @@
   Klass* k = SystemDictionary::resolve_from_stream(class_name,
                                                    class_loader,
                                                    protection_domain,
-                                                   &st,
+                                                   &st, KlassHandle(),
                                                    CHECK_NULL);
 
   if (log_is_enabled(Debug, class, resolve) && k != NULL) {
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/prims/jvmtiEnv.cpp
--- a/src/share/vm/prims/jvmtiEnv.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/prims/jvmtiEnv.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -50,6 +50,7 @@
 #include "prims/jvmtiManageCapabilities.hpp"
 #include "prims/jvmtiRawMonitor.hpp"
 #include "prims/jvmtiRedefineClasses.hpp"
+#include "prims/jvmtiRedefineClasses2.hpp"
 #include "prims/jvmtiTagMap.hpp"
 #include "prims/jvmtiThreadState.inline.hpp"
 #include "prims/jvmtiUtil.hpp"
@@ -381,8 +382,10 @@
 // is_modifiable_class_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::IsModifiableClass(oop k_mirror, jboolean* is_modifiable_class_ptr) {
-  *is_modifiable_class_ptr = VM_RedefineClasses::is_modifiable_class(k_mirror)?
-                                                       JNI_TRUE : JNI_FALSE;
+  bool is_modifiable_class = AllowEnhancedClassRedefinition ?
+    VM_EnhancedRedefineClasses::is_modifiable_class(k_mirror) :
+    VM_RedefineClasses::is_modifiable_class(k_mirror);
+  *is_modifiable_class_ptr = is_modifiable_class ? JNI_TRUE : JNI_FALSE;
   return JVMTI_ERROR_NONE;
 } /* end IsModifiableClass */
 
@@ -445,6 +448,11 @@
     }
     class_definitions[index].klass              = jcls;
   }
+  if (AllowEnhancedClassRedefinition) {
+    VM_EnhancedRedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_retransform);
+    VMThread::execute(&op);
+    return (op.check_error());
+  }
   VM_RedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_retransform);
   VMThread::execute(&op);
   return (op.check_error());
@@ -456,6 +464,11 @@
 jvmtiError
 JvmtiEnv::RedefineClasses(jint class_count, const jvmtiClassDefinition* class_definitions) {
 //TODO: add locking
+  if (AllowEnhancedClassRedefinition) {
+    VM_EnhancedRedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_redefine);
+    VMThread::execute(&op);
+    return (op.check_error());
+  }
   VM_RedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_redefine);
   VMThread::execute(&op);
   return (op.check_error());
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/prims/jvmtiExport.hpp
--- a/src/share/vm/prims/jvmtiExport.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/prims/jvmtiExport.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -189,6 +189,7 @@
   // systems as needed to relax invariant checks.
   static bool _has_redefined_a_class;
   friend class VM_RedefineClasses;
+  friend class VM_EnhancedRedefineClasses;
   inline static void set_has_redefined_a_class() {
     JVMTI_ONLY(_has_redefined_a_class = true;)
   }
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/prims/jvmtiImpl.cpp
--- a/src/share/vm/prims/jvmtiImpl.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/prims/jvmtiImpl.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -291,6 +291,11 @@
   Symbol* m_name = _method->name();
   Symbol* m_signature = _method->signature();
 
+  // (DCEVM) Go through old versions of method
+  for (Method* m = _method->old_version(); m != NULL; m = m->old_version()) {
+    (m->*meth_act)(_bci);
+  }
+
   // search previous versions if they exist
   for (InstanceKlass* pv_node = ikh->previous_versions();
        pv_node != NULL;
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/prims/jvmtiRedefineClasses2.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/vm/prims/jvmtiRedefineClasses2.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -0,0 +1,2149 @@
+/*
+ * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "classfile/javaClasses.inline.hpp"
+#include "classfile/klassFactory.hpp"
+#include "precompiled/precompiled.hpp"
+#include "classfile/systemDictionary.hpp"
+#include "classfile/verifier.hpp"
+#include "code/codeCache.hpp"
+#include "interpreter/oopMapCache.hpp"
+#include "interpreter/rewriter.hpp"
+#include "gc/shared/gcLocker.hpp"
+#include "memory/universe.inline.hpp"
+#include "memory/metaspaceShared.hpp"
+#include "oops/fieldStreams.hpp"
+#include "oops/klassVtable.hpp"
+#include "prims/jvmtiImpl.hpp"
+#include "prims/jvmtiRedefineClasses2.hpp"
+#include "prims/methodComparator.hpp"
+#include "prims/jvmtiClassFileReconstituter.hpp"
+#include "runtime/deoptimization.hpp"
+#include "runtime/relocator.hpp"
+#include "utilities/bitMap.inline.hpp"
+#include "compiler/compileBroker.hpp"
+#include "oops/instanceMirrorKlass.hpp"
+#include "utilities/pair.hpp"
+//#include "memory/sharedHeap.hpp"
+#include "gc/serial/markSweep.hpp"
+
+Array<Method*>* VM_EnhancedRedefineClasses::_old_methods = NULL;
+Array<Method*>* VM_EnhancedRedefineClasses::_new_methods = NULL;
+int*        VM_EnhancedRedefineClasses::_matching_old_methods = NULL;
+int*        VM_EnhancedRedefineClasses::_matching_new_methods = NULL;
+int*        VM_EnhancedRedefineClasses::_deleted_methods      = NULL;
+int*        VM_EnhancedRedefineClasses::_added_methods        = NULL;
+int         VM_EnhancedRedefineClasses::_matching_methods_length = 0;
+int         VM_EnhancedRedefineClasses::_deleted_methods_length  = 0;
+int         VM_EnhancedRedefineClasses::_added_methods_length    = 0;
+GrowableArray<instanceKlassHandle>* VM_EnhancedRedefineClasses::_affected_klasses = NULL;
+
+#define RC_TRACE_ENABLED(level) ((1) != 0)
+
+#define RC_TRACE_WITH_THREAD(level, thread, args) do { \
+    ResourceMark rm(thread); \
+    tty->print("RedefineClasses-0x%x: ", level); \
+    tty->print_cr args; \
+} while (0)
+
+#define RC_TRACE_MESG(args) do { \
+  ResourceMark rm; \
+  tty->print("RedefineClasses: "); \
+  tty->print_cr args; \
+} while (0)
+
+#define RC_TRACE(level, args) do { \
+    ResourceMark rm; \
+    tty->print("RedefineClasses-0x%x: ", level); \
+    tty->print_cr args; \
+} while (0)
+        
+        //todo: usunac to co wyzej i przejsc na poprawne logowanie
+
+// Holds the revision number of the current class redefinition
+int    VM_EnhancedRedefineClasses::_revision_number = -1;
+
+VM_EnhancedRedefineClasses::VM_EnhancedRedefineClasses(jint class_count, const jvmtiClassDefinition *class_defs, JvmtiClassLoadKind class_load_kind)
+   : VM_GC_Operation(Universe::heap()->total_full_collections(), GCCause::_heap_inspection) {
+  if (log_is_enabled(Info, redefine, class, timer)) {
+        _timer_total.start();
+    }
+  _class_count = class_count;
+  _class_defs = class_defs;
+  _class_load_kind = class_load_kind;
+  _result = JVMTI_ERROR_NONE;
+}
+
+void VM_EnhancedRedefineClasses::add_affected_klasses( Klass* klass )
+{
+  assert(!_affected_klasses->contains(klass), "must not occur more than once!");
+  assert(klass->new_version() == NULL, "Only last version is valid entry in system dictionary");
+
+  if (klass->check_redefinition_flag(Klass::MarkedAsAffected)) {
+    _affected_klasses->append(klass);
+    return;
+  }
+
+  for (juint i = 0; i < klass->super_depth(); i++) {
+    Klass* primary = klass->primary_super_of_depth(i);
+    // super_depth returns "8" for interfaces, but they don't have primaries other than Object.
+    if (primary == NULL) {
+      break;
+    }
+    if (primary->check_redefinition_flag(Klass::MarkedAsAffected)) {
+      RC_TRACE(0x00000001, ("Found affected class: %s", klass->name()->as_C_string()));
+      klass->set_redefinition_flag(Klass::MarkedAsAffected);
+      _affected_klasses->append(klass);
+      return;
+    }
+  }
+
+  // Check secondary supers
+  int cnt = klass->secondary_supers()->length();
+  for (int i = 0; i < cnt; i++) {
+    Klass* secondary = klass->secondary_supers()->at(i);
+    if (secondary->check_redefinition_flag(Klass::MarkedAsAffected)) {
+      RC_TRACE(0x00000001, ("Found affected class: %s", klass->name()->as_C_string()));
+      klass->set_redefinition_flag(Klass::MarkedAsAffected);
+      _affected_klasses->append(klass);
+      return;
+    }
+  }
+}
+
+
+// Searches for all affected classes and performs a sorting such that a supertype is always before a subtype.
+jvmtiError VM_EnhancedRedefineClasses::find_sorted_affected_classes() {
+
+  assert(_affected_klasses, "");
+  for (int i = 0; i < _class_count; i++) {
+    oop mirror = JNIHandles::resolve_non_null(_class_defs[i].klass);
+    instanceKlassHandle klass_handle(Thread::current(), java_lang_Class::as_Klass(mirror));
+    klass_handle->set_redefinition_flag(Klass::MarkedAsAffected);
+    assert(klass_handle->new_version() == NULL, "Must be new class");
+    RC_TRACE(0x00000001, ("Class being reloaded: %s", klass_handle->name()->as_C_string()));
+  }
+
+  // Find classes not directly redefined, but affected by a redefinition (because one of its supertypes is redefined)
+  SystemDictionary::classes_do(VM_EnhancedRedefineClasses::add_affected_klasses);
+  RC_TRACE(0x00000001, ("%d classes affected", _affected_klasses->length()));
+
+  // Sort the affected klasses such that a supertype is always on a smaller array index than its subtype.
+  jvmtiError result = do_topological_class_sorting(_class_defs, _class_count, Thread::current());
+  if (RC_TRACE_ENABLED(0x00000001)) {
+    RC_TRACE(0x00000001, ("Redefine order: "));
+    for (int i = 0; i < _affected_klasses->length(); i++) {
+      RC_TRACE(0x00000001, ("%s", _affected_klasses->at(i)->name()->as_C_string()));
+    }
+  }
+
+  return result;
+}
+
+// Searches for the class bytes of the given class and returns them as a byte array.
+jvmtiError VM_EnhancedRedefineClasses::find_class_bytes(instanceKlassHandle the_class, const unsigned char **class_bytes, jint *class_byte_count, jboolean *not_changed) {
+
+  *not_changed = false;
+
+  // Search for the index in the redefinition array that corresponds to the current class
+  int j;
+  for (j=0; j<_class_count; j++) {
+    oop mirror = JNIHandles::resolve_non_null(_class_defs[j].klass);
+    Klass* the_class_oop = java_lang_Class::as_Klass(mirror);
+    if (the_class_oop == the_class()) {
+      break;
+    }
+  }
+
+  if (j == _class_count) {
+
+    *not_changed = true;
+
+    // Redefine with same bytecodes. This is a class that is only indirectly affected by redefinition,
+    // so the user did not specify a different bytecode for that class.
+
+    if (the_class->get_cached_class_file_bytes() == NULL) {
+      // not cached, we need to reconstitute the class file from VM representation
+      constantPoolHandle  constants(Thread::current(), the_class->constants());
+      ObjectLocker ol(Handle(THREAD, constants), Thread::current());
+
+      JvmtiClassFileReconstituter reconstituter(the_class);
+      if (reconstituter.get_error() != JVMTI_ERROR_NONE) {
+        return reconstituter.get_error();
+      }
+
+      *class_byte_count = (jint)reconstituter.class_file_size();
+      *class_bytes      = (unsigned char*)reconstituter.class_file_bytes();
+    } else {
+
+      // it is cached, get it from the cache
+      *class_byte_count = the_class->get_cached_class_file_len();
+      *class_bytes      = the_class->get_cached_class_file_bytes();
+    }
+
+  } else {
+
+    // Redefine with bytecodes at index j
+    *class_bytes = _class_defs[j].class_bytes;
+    *class_byte_count = _class_defs[j].class_byte_count;
+  }
+
+  return JVMTI_ERROR_NONE;
+}
+
+// Prologue of the VM operation, called on the Java thread in parallel to normal program execution
+bool VM_EnhancedRedefineClasses::doit_prologue() {
+
+  _revision_number++;
+  RC_TRACE(0x00000001,
+        ("Redefinition with revision number %d started!", _revision_number));
+
+  assert(Thread::current()->is_Java_thread(), "must be Java thread");
+  if (log_is_enabled(Info, redefine, class, timer)) {
+        _timer_prologue.start();
+    }
+
+  if (!check_arguments()) {
+    _timer_prologue.stop();
+    return false;
+  }
+
+  // We first load new class versions in the prologue, because somewhere down the
+  // call chain it is required that the current thread is a Java thread.
+  _new_classes = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<instanceKlassHandle>(5, true);
+
+  assert(_affected_klasses == NULL, "");
+  _affected_klasses = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<instanceKlassHandle>(_class_count, true);
+
+  _result = load_new_class_versions(Thread::current());
+
+  RC_TRACE(0x00000001,
+        ("Loaded new class versions!"));
+  if (_result != JVMTI_ERROR_NONE) {
+    RC_TRACE(0x00000001,
+          ("error occured: %d!", _result));
+    delete _new_classes;
+    _new_classes = NULL;
+    delete _affected_klasses;
+    _affected_klasses = NULL;
+    _timer_prologue.stop();
+    return false;
+  }
+
+  VM_GC_Operation::doit_prologue();
+  _timer_prologue.stop();
+
+  RC_TRACE(0x00000001, ("doit_prologue finished!"));
+  return true;
+}
+
+// Checks basic properties of the arguments of the redefinition command.
+jvmtiError VM_EnhancedRedefineClasses::check_arguments_error() {
+  if (_class_defs == NULL) return JVMTI_ERROR_NULL_POINTER;
+  for (int i = 0; i < _class_count; i++) {
+    if (_class_defs[i].klass == NULL) return JVMTI_ERROR_INVALID_CLASS;
+    if (_class_defs[i].class_byte_count == 0) return JVMTI_ERROR_INVALID_CLASS_FORMAT;
+    if (_class_defs[i].class_bytes == NULL) return JVMTI_ERROR_NULL_POINTER;
+  }
+  return JVMTI_ERROR_NONE;
+  }
+
+// Returns false and sets an result error code if the redefinition should be aborted.
+bool VM_EnhancedRedefineClasses::check_arguments() {
+  jvmtiError error = check_arguments_error();
+  if (error != JVMTI_ERROR_NONE || _class_count == 0) {
+    _result = error;
+    return false;
+  }
+  return true;
+}
+
+jvmtiError VM_EnhancedRedefineClasses::check_exception() const {
+  Thread* THREAD = Thread::current();
+  if (HAS_PENDING_EXCEPTION) {
+
+    Symbol* ex_name = PENDING_EXCEPTION->klass()->name();
+    RC_TRACE_WITH_THREAD(0x00000002, THREAD, ("parse_stream exception: '%s'", ex_name->as_C_string()));
+    CLEAR_PENDING_EXCEPTION;
+
+    if (ex_name == vmSymbols::java_lang_UnsupportedClassVersionError()) {
+      return JVMTI_ERROR_UNSUPPORTED_VERSION;
+    } else if (ex_name == vmSymbols::java_lang_ClassFormatError()) {
+      return JVMTI_ERROR_INVALID_CLASS_FORMAT;
+    } else if (ex_name == vmSymbols::java_lang_ClassCircularityError()) {
+      return JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION;
+    } else if (ex_name == vmSymbols::java_lang_NoClassDefFoundError()) {
+      // The message will be "XXX (wrong name: YYY)"
+      return JVMTI_ERROR_NAMES_DONT_MATCH;
+    } else if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
+      return JVMTI_ERROR_OUT_OF_MEMORY;
+    } else {
+      // Just in case more exceptions can be thrown..
+      return JVMTI_ERROR_FAILS_VERIFICATION;
+    }
+  }
+
+  return JVMTI_ERROR_NONE;
+}
+
+// Loads all new class versions and stores the InstanceKlass handles in an array.
+jvmtiError VM_EnhancedRedefineClasses::load_new_class_versions(TRAPS) {
+
+  ResourceMark rm(THREAD);
+
+  RC_TRACE(0x00000001,
+        ("loading new class versions (%d)", _class_count));
+
+  // Retrieve an array of all classes that need to be redefined
+  jvmtiError err = find_sorted_affected_classes();
+  if (err != JVMTI_ERROR_NONE) {
+    RC_TRACE(0x00000001,
+          ("Error finding sorted affected classes: %d", (int)err));
+    return err;
+  }
+
+
+  JvmtiThreadState *state = JvmtiThreadState::state_for(JavaThread::current());
+
+  _max_redefinition_flags = Klass::NoRedefinition;
+  jvmtiError result = JVMTI_ERROR_NONE;
+
+  for (int i = 0; i < _affected_klasses->length(); i++) {
+    instanceKlassHandle the_class = _affected_klasses->at(i);
+
+    RC_TRACE(0x00000001,
+            ("Processing affected class %s (%d of %d)",
+                the_class->name()->as_C_string(),
+                i + 1,
+                _affected_klasses->length()));
+
+    the_class->link_class(THREAD);
+    result = check_exception();
+    if (result != JVMTI_ERROR_NONE) break;
+
+    // Find new class bytes
+    const unsigned char* class_bytes;
+    jint class_byte_count;
+    jvmtiError error;
+    jboolean not_changed;
+    if ((error = find_class_bytes(the_class, &class_bytes, &class_byte_count, &not_changed)) != JVMTI_ERROR_NONE) {
+      RC_TRACE_WITH_THREAD(0x00000002, THREAD,
+            ("Error finding class bytes: %d", (int)error));
+      result = error;
+      break;
+    }
+    assert(class_bytes != NULL && class_byte_count != 0, "Class bytes defined at this point!");
+
+
+    // Set redefined class handle in JvmtiThreadState class.
+    // This redefined class is sent to agent event handler for class file
+    // load hook event.
+    state->set_class_being_redefined(&the_class, _class_load_kind);
+
+    _timer_prologue.stop();
+    if (log_is_enabled(Info, redefine, class, timer)) {
+            _timer_class_loading.start();
+        }
+
+    // Parse the stream.
+    Handle the_class_loader(THREAD, the_class->class_loader());
+    Handle protection_domain(THREAD, the_class->protection_domain());
+    ClassFileStream st((u1*) class_bytes, class_byte_count, (char *)"__VM_EhnancedRedefineClasses__");
+
+    Klass* klass =
+        SystemDictionary::resolve_from_stream(
+            the_class->name(),
+            the_class_loader,
+            protection_domain,
+            &st,
+            the_class,
+            THREAD);
+    instanceKlassHandle new_class(THREAD, klass);
+
+    _timer_class_loading.stop();
+    if (log_is_enabled(Info, redefine, class, timer)) {
+            _timer_prologue.start();
+        }
+
+    // Clear class_being_redefined just to be sure.
+    state->clear_class_being_redefined();
+
+    result = check_exception();
+    if (result != JVMTI_ERROR_NONE) break;
+
+    not_changed = false;
+
+#ifdef ASSERT
+
+    assert(new_class() != NULL, "Class could not be loaded!");
+    assert(new_class() != the_class(), "must be different");
+    assert(new_class->new_version() == NULL && new_class->old_version() != NULL, "");
+
+
+    Array<Klass*>* k_interfaces = new_class->local_interfaces();
+    for (int j = 0; j < k_interfaces->length(); j++) {
+      assert(k_interfaces->at(j)->is_newest_version(), "just checking");
+    }
+
+    if (!THREAD->is_Compiler_thread()) {
+      RC_TRACE(0x00000001, ("name=%s loader="INTPTR_FORMAT" protection_domain="INTPTR_FORMAT,
+                                               the_class->name()->as_C_string(),
+                                               (intptr_t) (oopDesc*) the_class->class_loader(),
+                                               (intptr_t) (oopDesc*) the_class->protection_domain()));
+      // If we are on the compiler thread, we must not try to resolve a class.
+      Klass* systemLookup = SystemDictionary::resolve_or_null(the_class->name(), the_class->class_loader(), the_class->protection_domain(), THREAD);
+
+      if (systemLookup != NULL) {
+        assert(systemLookup == new_class->old_version(), "Old class must be in system dictionary!");
+        Klass *subklass = new_class()->subklass();
+        while (subklass != NULL) {
+          assert(subklass->new_version() == NULL, "Most recent version of class!");
+          subklass = subklass->next_sibling();
+        }
+      } else {
+        // This can happen for reflection generated classes.. ?
+        CLEAR_PENDING_EXCEPTION;
+      }
+    }
+
+#endif
+
+    if (RC_TRACE_ENABLED(0x00000001)) {
+      if (new_class->layout_helper() != the_class->layout_helper()) {
+        RC_TRACE(0x00000001,
+              ("Instance size change for class %s: new=%d old=%d",
+                  new_class->name()->as_C_string(),
+                  new_class->layout_helper(),
+                  the_class->layout_helper()));
+      }
+    }
+
+    // Set the new version of the class
+    new_class->set_revision_number(_revision_number);
+    new_class->set_redefinition_index(i);
+    the_class->set_new_version(new_class());
+    _new_classes->append(new_class);
+
+    assert(new_class->new_version() == NULL, "");
+
+    int redefinition_flags = Klass::NoRedefinition;
+
+    if (not_changed) {
+      redefinition_flags = Klass::NoRedefinition;
+    } else {
+      redefinition_flags = calculate_redefinition_flags(new_class);
+      if (redefinition_flags >= Klass::RemoveSuperType) {
+        result = JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
+        break;
+      }
+    }
+
+    if (new_class->super() != NULL) {
+      redefinition_flags = redefinition_flags | new_class->super()->redefinition_flags();
+    }
+
+    for (int j = 0; j<new_class->local_interfaces()->length(); j++) {
+      redefinition_flags = redefinition_flags | (new_class->local_interfaces()->at(j))->redefinition_flags();
+    }
+
+    new_class->set_redefinition_flags(redefinition_flags);
+
+    _max_redefinition_flags = _max_redefinition_flags | redefinition_flags;
+
+    if ((redefinition_flags & Klass::ModifyInstances) != 0) {
+      // TODO: Check if watch access flags of static fields are updated correctly.
+      calculate_instance_update_information(_new_classes->at(i)());
+    } else {
+      // Fields were not changed, transfer special flags only
+      assert(new_class->layout_helper() >> 1 == new_class->old_version()->layout_helper() >> 1, "must be equal");
+      assert(new_class->fields()->length() == InstanceKlass::cast(new_class->old_version())->fields()->length(), "must be equal");
+      
+      JavaFieldStream old_fs(the_class);
+      JavaFieldStream new_fs(new_class);
+      for (; !old_fs.done() && !new_fs.done(); old_fs.next(), new_fs.next()) {
+        AccessFlags flags = new_fs.access_flags();
+        flags.set_is_field_modification_watched(old_fs.access_flags().is_field_modification_watched());
+        flags.set_is_field_access_watched(old_fs.access_flags().is_field_access_watched());
+        new_fs.set_access_flags(flags);
+      }
+    }
+
+    if (RC_TRACE_ENABLED(0x00000001)) {
+      RC_TRACE(0x00000001,
+            ("Super class is %s", new_class->super()->name()->as_C_string()));
+    }
+
+#ifdef ASSERT
+    assert(new_class->super() == NULL || new_class->super()->new_version() == NULL, "Super klass must be newest version!");
+
+    the_class->vtable()->verify(tty);
+    new_class->vtable()->verify(tty);
+#endif
+
+    if (i == _affected_klasses->length() - 1) {
+      // This was the last class processed => check if additional classes have been loaded in the meantime
+      for (int j = 0; j<_affected_klasses->length(); j++) {
+
+        Klass* initial_klass = _affected_klasses->at(j)();
+        Klass *initial_subklass = initial_klass->subklass();
+        Klass *cur_klass = initial_subklass;
+        while(cur_klass != NULL) {
+
+          if(cur_klass->is_instance_klass() && cur_klass->is_newest_version() && !cur_klass->is_redefining()) {
+            instanceKlassHandle handle(THREAD, cur_klass);
+            if (!_affected_klasses->contains(handle)) {
+
+              int k = i + 1;
+              for (; k<_affected_klasses->length(); k++) {
+                if (_affected_klasses->at(k)->is_subtype_of(cur_klass)) {
+                  break;
+                }
+              }
+              _affected_klasses->insert_before(k, handle);
+              RC_TRACE(0x00000001,
+                    ("Adding newly loaded class to affected classes: %s", cur_klass->name()->as_C_string()));
+            }
+      }
+
+          cur_klass = cur_klass->next_sibling();
+        }
+      }
+
+      int new_count = _affected_klasses->length() - 1 - i;
+      if (new_count != 0) {
+        RC_TRACE(0x00000001,
+              ("Found new number of affected classes: %d", new_count));
+      }
+    }
+  }
+
+  if (result != JVMTI_ERROR_NONE) {
+    rollback();
+    return result;
+  }
+
+  _timer_prologue.stop();
+  if (log_is_enabled(Info, redefine, class, timer)) {
+        _timer_class_linking.start();
+    }
+  // Link and verify new classes _after_ all classes have been updated in the system dictionary!
+  for (int i=0; i<_affected_klasses->length(); i++) {
+    instanceKlassHandle the_class = _affected_klasses->at(i);
+    instanceKlassHandle new_class(the_class->new_version());
+
+    RC_TRACE(0x00000001,
+          ("Linking class %d/%d %s", i, _affected_klasses->length(), the_class->name()->as_C_string()));
+    new_class->link_class(THREAD);
+
+    result = check_exception();
+    if (result != JVMTI_ERROR_NONE) break;
+  }
+  _timer_class_linking.stop();
+    if (log_is_enabled(Info, redefine, class, timer)) {
+        _timer_prologue.start();
+    }
+  if (result != JVMTI_ERROR_NONE) {
+    rollback();
+    return result;
+  }
+
+  RC_TRACE(0x00000001, ("All classes loaded!"));
+
+#ifdef ASSERT
+  for (int i=0; i<_affected_klasses->length(); i++) {
+    instanceKlassHandle the_class = _affected_klasses->at(i);
+    assert(the_class->new_version() != NULL, "Must have been redefined");
+    instanceKlassHandle new_version = instanceKlassHandle(THREAD, the_class->new_version());
+    assert(new_version->new_version() == NULL, "Must be newest version");
+
+    if (!(new_version->super() == NULL || new_version->super()->new_version() == NULL)) {
+      new_version()->print();
+      new_version->super()->print();
+    }
+    assert(new_version->super() == NULL || new_version->super()->new_version() == NULL, "Super class must be newest version");
+  }
+
+  SystemDictionary::classes_do(check_class, THREAD);
+
+#endif
+
+  RC_TRACE(0x00000001, ("Finished verification!"));
+  return JVMTI_ERROR_NONE;
+}
+
+int VM_EnhancedRedefineClasses::calculate_redefinition_flags(instanceKlassHandle new_class) {
+
+  int result = Klass::NoRedefinition;
+  RC_TRACE(0x00000001,
+        ("Comparing different class versions of class %s", new_class->name()->as_C_string()));
+
+  assert(new_class->old_version() != NULL, "must have old version");
+  instanceKlassHandle the_class(new_class->old_version());
+
+  // Check whether class is in the error init state.
+  if (the_class->is_in_error_state()) {
+    // TBD #5057930: special error code is needed in 1.6
+    //result = Klass::union_redefinition_level(result, Klass::Invalid);
+  }
+
+  int i;
+
+  //////////////////////////////////////////////////////////////////////////////////////////////////////////
+  // Check superclasses
+  assert(new_class->super() == NULL || new_class->super()->is_newest_version(), "");
+  if (the_class->super() != new_class->super()) {
+    // Super class changed
+    Klass* cur_klass = the_class->super();
+    while (cur_klass != NULL) {
+      if (!new_class->is_subclass_of(cur_klass->newest_version())) {
+        RC_TRACE(0x00000001,
+              ("Removed super class %s", cur_klass->name()->as_C_string()));
+        result = result | Klass::RemoveSuperType | Klass::ModifyInstances | Klass::ModifyClass;
+
+        if (!cur_klass->has_subtype_changed()) {
+          RC_TRACE(0x00000001,
+                ("Subtype changed of class %s", cur_klass->name()->as_C_string()));
+          cur_klass->set_subtype_changed(true);
+        }
+  }
+
+      cur_klass = cur_klass->super();
+  }
+
+    cur_klass = new_class->super();
+    while (cur_klass != NULL) {
+      if (!the_class->is_subclass_of(cur_klass->old_version())) {
+        RC_TRACE(0x00000001,
+              ("Added super class %s", cur_klass->name()->as_C_string()));
+        result = result | Klass::ModifyClass | Klass::ModifyInstances;
+      }
+      cur_klass = cur_klass->super();
+    }
+  }
+
+  //////////////////////////////////////////////////////////////////////////////////////////////////////////
+  // Check interfaces
+
+  // Interfaces removed?
+  Array<Klass*>* old_interfaces = the_class->transitive_interfaces();
+  for (i = 0; i<old_interfaces->length(); i++) {
+    instanceKlassHandle old_interface(old_interfaces->at(i));
+    if (!new_class->implements_interface_any_version(old_interface())) {
+      result = result | Klass::RemoveSuperType | Klass::ModifyClass;
+      RC_TRACE(0x00000001,
+            ("Removed interface %s", old_interface->name()->as_C_string()));
+
+      if (!old_interface->has_subtype_changed()) {
+        RC_TRACE(0x00000001,
+              ("Subtype changed of interface %s", old_interface->name()->as_C_string()));
+        old_interface->set_subtype_changed(true);
+      }
+    }
+  }
+
+  // Interfaces added?
+  Array<Klass*>* new_interfaces = new_class->transitive_interfaces();
+  for (i = 0; i<new_interfaces->length(); i++) {
+    if (!the_class->implements_interface_any_version(new_interfaces->at(i))) {
+      result = result | Klass::ModifyClass;
+      RC_TRACE(0x00000001,
+            ("Added interface %s", new_interfaces->at(i)->name()->as_C_string()));
+    }
+  }
+
+
+  // Check whether class modifiers are the same.
+  jushort old_flags = (jushort) the_class->access_flags().get_flags();
+  jushort new_flags = (jushort) new_class->access_flags().get_flags();
+  if (old_flags != new_flags) {
+    // TODO Can this have any effects?
+  }
+
+  // Check if the number, names, types and order of fields declared in these classes
+  // are the same.
+  JavaFieldStream old_fs(the_class);
+  JavaFieldStream new_fs(new_class);
+  for (; !old_fs.done() && !new_fs.done(); old_fs.next(), new_fs.next()) {
+    // access
+    old_flags = old_fs.access_flags().as_short();
+    new_flags = new_fs.access_flags().as_short();
+    if ((old_flags ^ new_flags) & JVM_RECOGNIZED_FIELD_MODIFIERS) {
+      // TODO can this have any effect?
+    }
+    // offset
+    if (old_fs.offset() != new_fs.offset()) {
+      result = result | Klass::ModifyInstances;
+    }
+    // name and signature
+    Symbol* name_sym1 = the_class->constants()->symbol_at(old_fs.name_index());
+    Symbol* sig_sym1 = the_class->constants()->symbol_at(old_fs.signature_index());
+    Symbol* name_sym2 = new_class->constants()->symbol_at(new_fs.name_index());
+    Symbol* sig_sym2 = new_class->constants()->symbol_at(new_fs.signature_index());
+    if (name_sym1 != name_sym2 || sig_sym1 != sig_sym2) {
+      result = result | Klass::ModifyInstances;
+    }
+  }
+
+  // If both streams aren't done then we have a differing number of
+  // fields.
+  if (!old_fs.done() || !new_fs.done()) {
+      result = result | Klass::ModifyInstances;
+    }
+
+  // Do a parallel walk through the old and new methods. Detect
+  // cases where they match (exist in both), have been added in
+  // the new methods, or have been deleted (exist only in the
+  // old methods).  The class file parser places methods in order
+  // by method name, but does not order overloaded methods by
+  // signature.  In order to determine what fate befell the methods,
+  // this code places the overloaded new methods that have matching
+  // old methods in the same order as the old methods and places
+  // new overloaded methods at the end of overloaded methods of
+  // that name. The code for this order normalization is adapted
+  // from the algorithm used in InstanceKlass::find_method().
+  // Since we are swapping out of order entries as we find them,
+  // we only have to search forward through the overloaded methods.
+  // Methods which are added and have the same name as an existing
+  // method (but different signature) will be put at the end of
+  // the methods with that name, and the name mismatch code will
+  // handle them.
+  Array<Method*>* k_old_methods(the_class->methods()); // FIXME-isd: handles???
+  Array<Method*>* k_new_methods(new_class->methods());
+  int n_old_methods = k_old_methods->length();
+  int n_new_methods = k_new_methods->length();
+
+  int ni = 0;
+  int oi = 0;
+  while (true) {
+    Method* k_old_method;
+    Method* k_new_method;
+    enum { matched, added, deleted, undetermined } method_was = undetermined;
+
+    if (oi >= n_old_methods) {
+      if (ni >= n_new_methods) {
+        break; // we've looked at everything, done
+      }
+      // New method at the end
+      k_new_method = k_new_methods->at(ni);
+      method_was = added;
+    } else if (ni >= n_new_methods) {
+      // Old method, at the end, is deleted
+      k_old_method = k_old_methods->at(oi);
+      method_was = deleted;
+    } else {
+      // There are more methods in both the old and new lists
+      k_old_method = k_old_methods->at(oi);
+      k_new_method = k_new_methods->at(ni);
+      if (k_old_method->name() != k_new_method->name()) {
+        // Methods are sorted by method name, so a mismatch means added
+        // or deleted
+        if (k_old_method->name()->fast_compare(k_new_method->name()) > 0) {
+          method_was = added;
+        } else {
+          method_was = deleted;
+        }
+      } else if (k_old_method->signature() == k_new_method->signature()) {
+        // Both the name and signature match
+        method_was = matched;
+        } else {
+          // The name matches, but the signature doesn't, which means we have to
+          // search forward through the new overloaded methods.
+          int nj;  // outside the loop for post-loop check
+          for (nj = ni + 1; nj < n_new_methods; nj++) {
+            Method* m = k_new_methods->at(nj);
+            if (k_old_method->name() != m->name()) {
+              // reached another method name so no more overloaded methods
+              method_was = deleted;
+              break;
+          }
+          if (k_old_method->signature() == m->signature()) {
+            // found a match so swap the methods
+            k_new_methods->at_put(ni, m);
+            k_new_methods->at_put(nj, k_new_method);
+            k_new_method = m;
+            method_was = matched;
+            break;
+          }
+        }
+
+        if (nj >= n_new_methods) {
+          // reached the end without a match; so method was deleted
+          method_was = deleted;
+        }
+      }
+    }
+
+    switch (method_was) {
+  case matched:
+    // methods match, be sure modifiers do too
+    old_flags = (jushort) k_old_method->access_flags().get_flags();
+    new_flags = (jushort) k_new_method->access_flags().get_flags();
+    if ((old_flags ^ new_flags) & ~(JVM_ACC_NATIVE)) {
+      // TODO Can this have any effects? Probably yes on vtables?
+      result = result | Klass::ModifyClass;
+    }
+    {
+      u2 new_num = k_new_method->method_idnum();
+      u2 old_num = k_old_method->method_idnum();
+      if (new_num != old_num) {
+        Method* idnum_owner = new_class->method_with_idnum(old_num);
+        if (idnum_owner != NULL) {
+          // There is already a method assigned this idnum -- switch them
+          idnum_owner->set_method_idnum(new_num);
+        }
+        k_new_method->set_method_idnum(old_num);
+        RC_TRACE(0x00008000,
+            ("swapping idnum of new and old method %d / %d!", new_num, old_num));
+      }
+    }
+    RC_TRACE(0x00008000, ("Method matched: new: %s [%d] == old: %s [%d]",
+                         k_new_method->name_and_sig_as_C_string(), ni,
+                         k_old_method->name_and_sig_as_C_string(), oi));
+    // advance to next pair of methods
+    ++oi;
+    ++ni;
+    break;
+  case added:
+    // method added, see if it is OK
+    new_flags = (jushort) k_new_method->access_flags().get_flags();
+    if ((new_flags & JVM_ACC_PRIVATE) == 0
+      // hack: private should be treated as final, but alas
+      || (new_flags & (JVM_ACC_FINAL|JVM_ACC_STATIC)) == 0) {
+        // new methods must be private
+        result = result | Klass::ModifyClass;
+    }
+    {
+      u2 num = new_class->next_method_idnum();
+      if (num == ConstMethod::UNSET_IDNUM) {
+        // cannot add any more methods
+        result = result | Klass::ModifyClass;
+      }
+      u2 new_num = k_new_method->method_idnum();
+      Method* idnum_owner = new_class->method_with_idnum(num);
+      if (idnum_owner != NULL) {
+        // There is already a method assigned this idnum -- switch them
+        idnum_owner->set_method_idnum(new_num);
+      }
+      k_new_method->set_method_idnum(num);
+    }
+    RC_TRACE(0x00008000, ("Method added: new: %s [%d], idnum %d",
+                         k_new_method->name_and_sig_as_C_string(), ni, k_new_method->method_idnum()));
+    ++ni; // advance to next new method
+    break;
+  case deleted:
+    // method deleted, see if it is OK
+    old_flags = (jushort) k_old_method->access_flags().get_flags();
+    if ((old_flags & JVM_ACC_PRIVATE) == 0
+      // hack: private should be treated as final, but alas
+      || (old_flags & (JVM_ACC_FINAL|JVM_ACC_STATIC)) == 0
+      ) {
+        // deleted methods must be private
+        result = result | Klass::ModifyClass;
+    }
+    RC_TRACE(0x00008000, ("Method deleted: old: %s [%d]",
+                          k_old_method->name_and_sig_as_C_string(), oi));
+    ++oi; // advance to next old method
+    break;
+  default:
+    ShouldNotReachHere();
+    }
+  }
+
+  if (new_class()->size() != new_class->old_version()->size()) {
+    result |= Klass::ModifyClassSize;
+  }
+
+  if (new_class->size_helper() != ((InstanceKlass*)(new_class->old_version()))->size_helper()) {
+    result |= Klass::ModifyInstanceSize;
+  }
+
+  // TODO Check method bodies to be able to return NoChange?
+  return result;
+}
+
+void VM_EnhancedRedefineClasses::calculate_instance_update_information(Klass* new_version) {
+
+  class CalculateFieldUpdates : public FieldClosure {
+
+  private:
+    InstanceKlass* _old_ik;
+    GrowableArray<int> _update_info;
+    int _position;
+    bool _copy_backwards;
+
+  public:
+
+    bool does_copy_backwards() {
+      return _copy_backwards;
+  }
+
+    CalculateFieldUpdates(InstanceKlass* old_ik) :
+        _old_ik(old_ik), _position(instanceOopDesc::base_offset_in_bytes()), _copy_backwards(false) {
+      _update_info.append(_position);
+      _update_info.append(0);
+  }
+
+    GrowableArray<int> &finish() {
+      _update_info.append(0);
+      return _update_info;
+  }
+
+    void do_field(fieldDescriptor* fd) {
+      int alignment = fd->offset() - _position;
+      if (alignment > 0) {
+        // This field was aligned, so we need to make sure that we fill the gap
+        fill(alignment);
+      }
+
+      assert(_position == fd->offset(), "must be correct offset!");
+
+      fieldDescriptor old_fd;
+      if (_old_ik->find_field(fd->name(), fd->signature(), false, &old_fd) != NULL) {
+        // Found field in the old class, copy
+        copy(old_fd.offset(), type2aelembytes(fd->field_type()));
+
+        if (old_fd.offset() < fd->offset()) {
+          _copy_backwards = true;
+        }
+
+        // Transfer special flags
+        fd->set_is_field_modification_watched(old_fd.is_field_modification_watched());
+        fd->set_is_field_access_watched(old_fd.is_field_access_watched());
+      } else {
+        // New field, fill
+        fill(type2aelembytes(fd->field_type()));
+      }
+  }
+
+  private:
+
+    void fill(int size) {
+      if (_update_info.length() > 0 && _update_info.at(_update_info.length() - 1) < 0) {
+        (*_update_info.adr_at(_update_info.length() - 1)) -= size;
+      } else {
+        _update_info.append(-size);
+      }
+      _position += size;
+    }
+
+    void copy(int offset, int size) {
+      int prev_end = -1;
+      if (_update_info.length() > 0 && _update_info.at(_update_info.length() - 1) > 0) {
+        prev_end = _update_info.at(_update_info.length() - 2) + _update_info.at(_update_info.length() - 1);
+      }
+
+      if (prev_end == offset) {
+        (*_update_info.adr_at(_update_info.length() - 2)) += size;
+      } else {
+        _update_info.append(size);
+        _update_info.append(offset);
+      }
+
+      _position += size;
+    }
+  };
+
+  InstanceKlass* ik = InstanceKlass::cast(new_version);
+  InstanceKlass* old_ik = InstanceKlass::cast(new_version->old_version());
+  CalculateFieldUpdates cl(old_ik);
+  ik->do_nonstatic_fields(&cl);
+
+  GrowableArray<int> result = cl.finish();
+  ik->store_update_information(result);
+  ik->set_copying_backwards(cl.does_copy_backwards());
+
+
+  if (RC_TRACE_ENABLED(0x00000001)) {
+    RC_TRACE(0x00000001, ("Instance update information for %s:", new_version->name()->as_C_string()));
+    if (cl.does_copy_backwards()) {
+      RC_TRACE(0x00000001, ("\tDoes copy backwards!"));
+    }
+    for (int i=0; i<result.length(); i++) {
+      int curNum = result.at(i);
+      if (curNum < 0) {
+        RC_TRACE(0x00000001, ("\t%d CLEAN", curNum));
+      } else if (curNum > 0) {
+        RC_TRACE(0x00000001, ("\t%d COPY from %d", curNum, result.at(i + 1)));
+        i++;
+      } else {
+        RC_TRACE(0x00000001, ("\tEND"));
+      }
+    }
+  }
+}
+
+void VM_EnhancedRedefineClasses::rollback() {
+  RC_TRACE(0x00000001, ("Rolling back redefinition!"));
+  SystemDictionary::rollback_redefinition();
+
+  for (int i=0; i<_new_classes->length(); i++) {
+    SystemDictionary::remove_from_hierarchy(_new_classes->at(i));
+  }
+
+  for (int i=0; i<_new_classes->length(); i++) {
+    instanceKlassHandle new_class = _new_classes->at(i);
+    new_class->set_redefining(false);
+    new_class->old_version()->set_new_version(NULL);
+    new_class->set_old_version(NULL);
+  }
+
+}
+
+void VM_EnhancedRedefineClasses::swap_marks(oop first, oop second) {
+  markOop first_mark = first->mark();
+  markOop second_mark = second->mark();
+  first->set_mark(second_mark);
+  second->set_mark(first_mark);
+}
+
+class FieldCopier : public FieldClosure {
+  public:
+  void do_field(fieldDescriptor* fd) {
+    InstanceKlass* cur = InstanceKlass::cast(fd->field_holder());
+    oop cur_oop = cur->java_mirror();
+
+    InstanceKlass* old = InstanceKlass::cast(cur->old_version());
+    oop old_oop = old->java_mirror();
+
+    fieldDescriptor result;
+    bool found = old->find_local_field(fd->name(), fd->signature(), &result);
+    if (found && result.is_static()) {
+      RC_TRACE(0x00000001, ("Copying static field value for field %s old_offset=%d new_offset=%d",
+                                               fd->name()->as_C_string(), result.offset(), fd->offset()));
+      memcpy(cur_oop->obj_field_addr<HeapWord>(fd->offset()),
+             old_oop->obj_field_addr<HeapWord>(result.offset()),
+             type2aelembytes(fd->field_type()));
+
+      // Static fields may have references to java.lang.Class
+      if (fd->field_type() == T_OBJECT) {
+         oop oop = cur_oop->obj_field(fd->offset());
+         if (oop != NULL && (!oop->is_instance() || !InstanceKlass::cast(oop->klass())->is_mirror_instance_klass())) {
+            Klass* klass = java_lang_Class::as_Klass(oop);
+            if (klass != NULL && klass->is_instance_klass()) {
+              assert(oop == InstanceKlass::cast(klass)->java_mirror(), "just checking");
+              if (klass->new_version() != NULL) {
+                oop = InstanceKlass::cast(klass->new_version())->java_mirror();
+                cur_oop->obj_field_put(fd->offset(), oop);
+              }
+            }
+         }
+        }
+      }
+    }
+};
+
+void VM_EnhancedRedefineClasses::mark_as_scavengable(nmethod* nm) {
+  if (!nm->on_scavenge_root_list()) {
+    CodeCache::add_scavenge_root_nmethod(nm);
+  }
+}
+
+struct StoreBarrier {
+  template <class T> static void oop_store(T* p, oop v) { ::oop_store(p, v); }
+};
+
+struct StoreNoBarrier {
+  template <class T> static void oop_store(T* p, oop v) { oopDesc::encode_store_heap_oop_not_null(p, v); }
+};
+
+template <class S>
+class ChangePointersOopClosure : public ExtendedOopClosure {
+  // import java_lang_invoke_MemberName.*
+  enum {
+    REFERENCE_KIND_SHIFT = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,
+    REFERENCE_KIND_MASK  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,
+  };
+
+
+  bool update_member_name(oop obj) {
+    int flags    =       java_lang_invoke_MemberName::flags(obj);
+    int ref_kind =       (flags >> REFERENCE_KIND_SHIFT) & REFERENCE_KIND_MASK;
+    if (MethodHandles::ref_kind_is_method(ref_kind)) {
+      Method* m = (Method*) java_lang_invoke_MemberName::vmtarget(obj);
+      if (m != NULL && !m->method_holder()->is_newest_version()) {
+        // Let's try to re-resolve method
+        InstanceKlass* newest = InstanceKlass::cast(m->method_holder()->newest_version());
+        Method* new_method = newest->find_method(m->name(), m->signature());
+
+        if (new_method != NULL) {
+          // Note: we might set NULL at this point, which should force AbstractMethodError at runtime
+          CallInfo info(new_method, newest);
+          MethodHandles::init_method_MemberName(obj, info, true);
+        } else {
+          java_lang_invoke_MemberName::set_vmtarget(obj, NULL);
+        }
+      }
+    } else if (MethodHandles::ref_kind_is_field(ref_kind)) {
+      Klass* k = (Klass*) java_lang_invoke_MemberName::vmtarget(obj);
+      if (k == NULL) {
+        return false; // Was cleared before, this MemberName is invalid.
+      }
+
+      if (k != NULL && !k->is_newest_version()) {
+        // Let's try to re-resolve field
+        fieldDescriptor fd;
+        int offset = java_lang_invoke_MemberName::vmindex(obj);
+        bool is_static = MethodHandles::ref_kind_is_static(ref_kind);
+        InstanceKlass* ik = InstanceKlass::cast(k);
+        if (ik->find_local_field_from_offset(offset, is_static, &fd)) {
+          InstanceKlass* newest = InstanceKlass::cast(k->newest_version());
+          fieldDescriptor fd_new;
+          if (newest->find_local_field(fd.name(), fd.signature(), &fd_new)) {
+            MethodHandles::init_field_MemberName(obj, fd_new, MethodHandles::ref_kind_is_setter(ref_kind));
+          } else {
+            // Matching field is not found in new version, not much we can do here.
+            // JVM will crash once faulty MH is invoked.
+            // However, to avoid that all DMH's using this faulty MH are cleared (set to NULL)
+            // Eventually, we probably want to replace them with something more meaningful,
+            // like instance throwing NoSuchFieldError or DMH that will resort to dynamic
+            // field resolution (with possibility of type conversion)
+            java_lang_invoke_MemberName::set_vmtarget(obj, NULL);
+            java_lang_invoke_MemberName::set_vmindex(obj, 0);
+            return false;
+          }
+        }
+      }
+    }
+    return true;
+  }
+
+  bool update_direct_method_handle(oop obj) {
+    // Always update member name first.
+    oop mem_name = java_lang_invoke_DirectMethodHandle::member(obj);
+    if (!update_member_name(mem_name)) {
+      return false;
+    }
+
+    // Here we rely on DirectMethodHandle implementation.
+    // The current implementation caches field offset in $StaticAccessor/$Accessor
+    int flags    =       java_lang_invoke_MemberName::flags(mem_name);
+    int ref_kind =       (flags >> REFERENCE_KIND_SHIFT) & REFERENCE_KIND_MASK;
+    if (MethodHandles::ref_kind_is_field(ref_kind)) {
+      // Note: we don't care about staticBase field (which is java.lang.Class)
+      // It should be processed during normal object update.
+      // Update offset in StaticAccessor
+      int offset = java_lang_invoke_MemberName::vmindex(mem_name);
+      if (offset != 0) { // index of 0 means that field no longer exist
+        if (java_lang_invoke_DirectMethodHandle_StaticAccessor::is_instance(obj)) {
+          java_lang_invoke_DirectMethodHandle_StaticAccessor::set_static_offset(obj, offset);
+        } else if (java_lang_invoke_DirectMethodHandle_Accessor::is_instance(obj)) {
+          java_lang_invoke_DirectMethodHandle_Accessor::set_field_offset(obj, offset);
+        }
+      }
+    }
+    return true;
+  }
+
+  // Forward pointers to InstanceKlass and mirror class to new versions
+  template <class T>
+  inline void do_oop_work(T* p) {
+    oop obj = oopDesc::load_decode_heap_oop(p);
+    if (obj == NULL) {
+      return;
+    }
+    if (obj->is_instance() && InstanceKlass::cast(obj->klass())->is_mirror_instance_klass()) {
+      Klass* klass = java_lang_Class::as_Klass(obj);
+      if (klass != NULL && klass->is_instance_klass()) {
+        assert(obj == InstanceKlass::cast(klass)->java_mirror(), "just checking");
+        if (klass->new_version() != NULL) {
+          obj = InstanceKlass::cast(klass->new_version())->java_mirror();
+          S::oop_store(p, obj);
+        }
+      }
+    }
+
+    // JSR 292 support, uptade java.lang.invoke.MemberName instances
+    if (java_lang_invoke_MemberName::is_instance(obj)) {
+      update_member_name(obj);
+    } else if (java_lang_invoke_DirectMethodHandle::is_instance(obj)) {
+      if (!update_direct_method_handle(obj)) {
+        // DMH is no longer valid, replace it with null reference.
+        // See note above. We probably want to replace this with something more meaningful.
+        S::oop_store(p, NULL);
+      }
+    }
+  }
+
+  virtual void do_oop(oop* o) {
+    do_oop_work(o);
+  }
+
+  virtual void do_oop(narrowOop* o) {
+    do_oop_work(o);
+  }
+};
+
+class ChangePointersObjectClosure : public ObjectClosure {
+  private:
+
+  OopClosure *_closure;
+  bool _needs_instance_update;
+  oop _tmp_obj;
+  int _tmp_obj_size;
+
+public:
+  ChangePointersObjectClosure(OopClosure *closure) : _closure(closure), _needs_instance_update(false), _tmp_obj(NULL), _tmp_obj_size(0) {}
+
+  bool needs_instance_update() {
+    return _needs_instance_update;
+  }
+
+  void copy_to_tmp(oop o) {
+    int size = o->size();
+    if (_tmp_obj_size < size) {
+      _tmp_obj_size = size;
+      _tmp_obj = (oop)resource_allocate_bytes(size * HeapWordSize);
+    }
+    Copy::aligned_disjoint_words((HeapWord*)o, (HeapWord*)_tmp_obj, size);
+  }
+
+  virtual void do_object(oop obj) {
+    // FIXME: if (obj->is_instanceKlass()) return;
+    if (obj->is_instance() && InstanceKlass::cast(obj->klass())->is_mirror_instance_klass()) {
+      // static fields may have references to old java.lang.Class instances, update them
+      // at the same time, we don't want to update other oops in the java.lang.Class
+      // Causes SIGSEGV?
+      //instanceMirrorKlass::oop_fields_iterate(obj, _closure);
+    } else {
+      obj->oop_iterate_no_header(_closure);
+    }
+
+    if (obj->klass()->new_version() != NULL) {
+      Klass* new_klass = obj->klass()->new_version();
+      /* FIXME: if (obj->is_perm()) {
+        _needs_instance_update = true;
+      } else */if(new_klass->update_information() != NULL) {
+        int size_diff = obj->size() - obj->size_given_klass(new_klass);
+
+        // Either new size is bigger or gap is to small to be filled
+        if (size_diff < 0 || (size_diff > 0 && (size_t) size_diff < CollectedHeap::min_fill_size())) {
+          // We need an instance update => set back to old klass
+          _needs_instance_update = true;
+        } else {
+          oop src = obj;
+          if (new_klass->is_copying_backwards()) {
+            copy_to_tmp(obj);
+            src = _tmp_obj;
+          }
+          src->set_klass(obj->klass()->new_version());
+          MarkSweep::update_fields(obj, src, new_klass->update_information());
+
+          if (size_diff > 0) {
+            HeapWord* dead_space = ((HeapWord *)obj) + obj->size();
+            CollectedHeap::fill_with_object(dead_space, size_diff);
+          }
+        }
+      } else {
+        obj->set_klass(obj->klass()->new_version());
+      }
+    }
+  }
+};
+
+
+void VM_EnhancedRedefineClasses::doit() {
+
+  Thread *thread = Thread::current();
+
+  assert((_max_redefinition_flags & Klass::RemoveSuperType) == 0, "removing super types not allowed");
+
+  if (UseSharedSpaces) {
+    // Sharing is enabled so we remap the shared readonly space to
+    // shared readwrite, private just in case we need to redefine
+    // a shared class. We do the remap during the doit() phase of
+    // the safepoint to be safer.
+    if (!MetaspaceShared::remap_shared_readonly_as_readwrite()) {
+      RC_TRACE(0x00000001,
+        ("failed to remap shared readonly space to readwrite, private"));
+      _result = JVMTI_ERROR_INTERNAL;
+      return;
+    }
+  }
+
+  if (log_is_enabled(Info, redefine, class, timer)) {
+        _timer_prepare_redefinition.start();
+    }
+  for (int i = 0; i < _new_classes->length(); i++) {
+    redefine_single_class(_new_classes->at(i), thread);
+  }
+
+  // Deoptimize all compiled code that depends on this class
+  flush_dependent_code(instanceKlassHandle(Thread::current(), (Klass*)NULL), Thread::current());
+
+  // Adjust constantpool caches for all classes
+  // that reference methods of the evolved class.
+  ClearCpoolCacheAndUnpatch clear_cpool_cache(Thread::current());
+  ClassLoaderDataGraph::classes_do(&clear_cpool_cache);
+
+  _timer_prepare_redefinition.stop();
+  if (log_is_enabled(Info, redefine, class, timer)) {
+        _timer_heap_iteration.start();
+    }
+
+  ChangePointersOopClosure<StoreNoBarrier> oopClosureNoBarrier;
+  ChangePointersOopClosure<StoreBarrier> oopClosure;
+  ChangePointersObjectClosure objectClosure(&oopClosure);
+
+  RC_TRACE(0x00000001, ("Before updating instances"));
+  {
+    // Since we may update oops inside nmethod's code blob to point to java.lang.Class in new generation, we need to
+    // make sure such references are properly recognized by GC. For that, If ScavengeRootsInCode is true, we need to
+    // mark such nmethod's as "scavengable".
+    // For now, mark all nmethod's as scavengable that are not scavengable already
+    if (ScavengeRootsInCode) {
+      CodeCache::nmethods_do(mark_as_scavengable);
+    }
+
+    //SharedHeap::heap()->gc_prologue(true);
+        GenCollectedHeap::heap()->gc_prologue(true);
+        Universe::heap()->object_iterate(&objectClosure);
+        Universe::root_oops_do(&oopClosureNoBarrier);
+        //SharedHeap::heap()->gc_epilogue(false);
+        GenCollectedHeap::heap()->gc_epilogue(false);
+  }
+  RC_TRACE(0x00000001, ("After updating instances"));
+
+  for (int i = 0; i < _new_classes->length(); i++) {
+    InstanceKlass* cur = InstanceKlass::cast(_new_classes->at(i)());
+    InstanceKlass* old = InstanceKlass::cast(cur->old_version());
+
+    // Swap marks to have same hashcodes
+    markOop cur_mark = cur->prototype_header();
+    markOop old_mark = old->prototype_header();
+    cur->set_prototype_header(old_mark);
+    old->set_prototype_header(cur_mark);
+
+    //swap_marks(cur, old);
+    swap_marks(cur->java_mirror(), old->java_mirror());
+
+    // Revert pool holder for old version of klass (it was updated by one of ours closure!)
+    old->constants()->set_pool_holder(old);
+
+    Klass* array_klasses = old->array_klasses();
+    if (array_klasses != NULL) {
+      assert(cur->array_klasses() == NULL, "just checking");
+
+      // Transfer the array classes, otherwise we might get cast exceptions when casting array types.
+      // Also, set array klasses element klass.
+      cur->set_array_klasses(array_klasses);
+      ObjArrayKlass::cast(array_klasses)->set_element_klass(cur);
+      //ArrayKlass::cast(array_klasses)->set_component_mirror(cur->java_mirror()); //todo: czy mozna pominac?
+    }
+
+    // Initialize the new class! Special static initialization that does not execute the
+    // static constructor but copies static field values from the old class if name
+    // and signature of a static field match.
+    FieldCopier copier;
+    cur->do_local_static_fields(&copier); // TODO (tw): What about internal static fields??
+    //java_lang_Class::set_klass(old->java_mirror(), cur); // FIXME-isd: is that correct?
+    //FIXME-isd: do we need this: ??? old->set_java_mirror(cur->java_mirror());
+
+    // Transfer init state
+    InstanceKlass::ClassState state = old->init_state();
+    if (state > InstanceKlass::linked) {
+      cur->set_init_state(state);
+    }
+  }
+
+  _timer_heap_iteration.stop();
+  if (log_is_enabled(Info, redefine, class, timer)) {
+        _timer_redefinition.start();
+    }
+  if (objectClosure.needs_instance_update()) {
+    // Do a full garbage collection to update the instance sizes accordingly
+    RC_TRACE(0x00000001, ("Before performing full GC!"));
+    Universe::set_redefining_gc_run(true);
+    notify_gc_begin(true);
+    Universe::heap()->collect_as_vm_thread(GCCause::_heap_inspection);
+    notify_gc_end();
+    Universe::set_redefining_gc_run(false);
+    RC_TRACE(0x00000001, ("GC done!"));
+  }
+
+  // Unmark Klass*s as "redefining"
+  for (int i=0; i<_new_classes->length(); i++) {
+    Klass* cur_klass = _new_classes->at(i)();
+    InstanceKlass* cur = (InstanceKlass*)cur_klass;
+    cur->set_redefining(false);
+    cur->clear_update_information();
+  }
+
+  // Disable any dependent concurrent compilations
+  SystemDictionary::notice_modification();
+
+  // Update klass pointers
+  SystemDictionary::update_constraints_after_redefinition();
+
+  // Set flag indicating that some invariants are no longer true.
+  // See jvmtiExport.hpp for detailed explanation.
+  JvmtiExport::set_has_redefined_a_class();
+
+  // Clean up caches in the compiler interface and compiler threads
+  ciObjectFactory::resort_shared_ci_metadata();
+
+#ifdef ASSERT
+
+  // Universe::verify();
+  // JNIHandles::verify();
+
+  SystemDictionary::classes_do(check_class, thread);
+#endif
+
+  _timer_redefinition.stop();
+
+  if (TraceRedefineClasses > 0) {
+    tty->flush();
+  }
+}
+
+void VM_EnhancedRedefineClasses::doit_epilogue() {
+
+    if (log_is_enabled(Info, redefine, class, timer)) {
+        _timer_vm_op_epilogue.start();
+    }
+  
+  ResourceMark mark;
+
+  VM_GC_Operation::doit_epilogue();
+  RC_TRACE(0x00000001, ("GC Operation epilogue finished!"));
+
+  // Free the array of scratch classes
+  delete _new_classes;
+  _new_classes = NULL;
+
+  // Free the array of affected classes
+  delete _affected_klasses;
+  _affected_klasses = NULL;
+
+  RC_TRACE(0x00000001, ("Redefinition finished!"));
+
+  _timer_vm_op_epilogue.stop();
+}
+
+bool VM_EnhancedRedefineClasses::is_modifiable_class(oop klass_mirror) {
+  // classes for primitives cannot be redefined
+  if (java_lang_Class::is_primitive(klass_mirror)) {
+    return false;
+  }
+  Klass* klass = java_lang_Class::as_Klass(klass_mirror);
+  // classes for arrays cannot be redefined
+  if (klass == NULL || !klass->is_instance_klass()) {
+    return false;
+  }
+  return true;
+}
+
+#ifdef ASSERT
+
+void VM_EnhancedRedefineClasses::verify_classes(Klass* k_oop_latest, oop initiating_loader, TRAPS) {
+  Klass* k_oop = k_oop_latest;
+  while (k_oop != NULL) {
+
+    instanceKlassHandle k_handle(THREAD, k_oop);
+    Verifier::verify(k_handle, Verifier::ThrowException, true, THREAD);
+    k_oop = k_oop->old_version();
+  }
+}
+
+#endif
+
+// Rewrite faster byte-codes back to their slower equivalent. Undoes rewriting happening in templateTable_xxx.cpp
+// The reason is that once we zero cpool caches, we need to re-resolve all entries again. Faster bytecodes do not
+// do that, they assume that cache entry is resolved already.
+void VM_EnhancedRedefineClasses::unpatch_bytecode(Method* method) {
+  RawBytecodeStream bcs(method);
+  Bytecodes::Code code;
+  Bytecodes::Code java_code;
+  while (!bcs.is_last_bytecode()) {
+    code = bcs.raw_next();
+
+    // dcevm : workaround check _illegal in case of lambda methods etc.
+    // TODO: skip lambda/intrinsic before while loop?  (method()->is_method_handle_intrinsic() || method()->is_compiled_lambda_form())
+    if (code == Bytecodes::_illegal) {
+      return;
+    }
+
+    address bcp = bcs.bcp();
+
+    if (code == Bytecodes::_breakpoint) {
+      int bci = method->bci_from(bcp);
+      code = method->orig_bytecode_at(bci);
+      java_code = Bytecodes::java_code(code);
+      if (code != java_code &&
+           (java_code == Bytecodes::_getfield ||
+            java_code == Bytecodes::_putfield ||
+            java_code == Bytecodes::_aload_0)) {
+        // Let breakpoint table handling unpatch bytecode
+        method->set_orig_bytecode_at(bci, java_code);
+      }
+    } else {
+      java_code = Bytecodes::java_code(code);
+      if (code != java_code &&
+           (java_code == Bytecodes::_getfield ||
+            java_code == Bytecodes::_putfield ||
+            java_code == Bytecodes::_aload_0)) {
+        *bcp = java_code;
+      }
+    }
+
+    // Additionally, we need to unpatch bytecode at bcp+1 for fast_xaccess (which would be fast field access)
+    if (code == Bytecodes::_fast_iaccess_0 || code == Bytecodes::_fast_aaccess_0 || code == Bytecodes::_fast_faccess_0) {
+      Bytecodes::Code code2 = Bytecodes::code_or_bp_at(bcp + 1);
+      assert(code2 == Bytecodes::_fast_igetfield ||
+             code2 == Bytecodes::_fast_agetfield ||
+             code2 == Bytecodes::_fast_fgetfield, "");
+        *(bcp + 1) = Bytecodes::java_code(code2);
+      }
+    }
+  }
+
+// Unevolving classes may point to old methods directly
+// from their constant pool caches, itables, and/or vtables. We
+// use the SystemDictionary::classes_do() facility and this helper
+// to fix up these pointers. Additional field offsets and vtable indices
+// in the constant pool cache entries are fixed.
+//
+// Note: We currently don't support updating the vtable in
+// arrayKlassOops. See Open Issues in jvmtiRedefineClasses.hpp.
+void VM_EnhancedRedefineClasses::ClearCpoolCacheAndUnpatch::do_klass(Klass* klass) {
+  if (!klass->is_instance_klass()) {
+    return;
+  }
+  HandleMark hm(_thread);
+  InstanceKlass *ik = InstanceKlass::cast(klass);
+  constantPoolHandle other_cp = constantPoolHandle(ik->constants());
+
+  // Update host klass of anonymous classes (for example, produced by lambdas) to newest version.
+  if (ik->is_anonymous() && !ik->host_klass()->is_newest_version()) {
+    ik->set_host_klass(InstanceKlass::cast(ik->host_klass()->newest_version()));
+  }
+
+  for (int i = 0; i < other_cp->length(); i++) {
+    if (other_cp->tag_at(i).is_klass()) {
+      Klass* klass = other_cp->klass_at(i, _thread);
+      if (klass->new_version() != NULL) {
+        // (DCEVM) TODO: check why/if this is necessary
+        other_cp->klass_at_put(i, klass->new_version());
+      }
+      klass = other_cp->klass_at(i, _thread);
+      assert(klass->new_version() == NULL, "Must be new klass!");
+    }
+  }
+
+  ConstantPoolCache* cp_cache = other_cp->cache();
+  if (cp_cache != NULL) {
+    cp_cache->clear_entries();
+  }
+
+  // If bytecode rewriting is enabled, we also need to unpatch bytecode to force resolution of zeroed entries
+  if (RewriteBytecodes) {
+    ik->methods_do(unpatch_bytecode);
+  }
+}
+
+void VM_EnhancedRedefineClasses::update_jmethod_ids() {
+  for (int j = 0; j < _matching_methods_length; ++j) {
+    Method* old_method = _old_methods->at(_matching_old_methods[j]);
+    jmethodID jmid = old_method->find_jmethod_id_or_null();
+    RC_TRACE(0x00008000, ("matching method %s, jmid %d", old_method->name_and_sig_as_C_string(), *((int *)&jmid)));
+    if (old_method->new_version() != NULL && jmid == NULL) {
+       // (DCEVM) Have to create jmethodID in this case
+       jmid = old_method->jmethod_id();
+    }
+
+    if (jmid != NULL) {
+      // There is a jmethodID, change it to point to the new method
+      methodHandle new_method_h(_new_methods->at(_matching_new_methods[j]));
+      if (old_method->new_version() == NULL) {
+        methodHandle old_method_h(_old_methods->at(_matching_old_methods[j]));
+        jmethodID new_jmethod_id = Method::make_jmethod_id(old_method_h->method_holder()->class_loader_data(), old_method_h());
+        bool result = InstanceKlass::cast(old_method_h->method_holder())->update_jmethod_id(old_method_h(), new_jmethod_id);
+      } else {
+        jmethodID mid = new_method_h->jmethod_id();
+        bool result = InstanceKlass::cast(new_method_h->method_holder())->update_jmethod_id(new_method_h(), jmid);
+      }
+      Method::change_method_associated_with_jmethod_id(jmid, new_method_h());
+      assert(Method::resolve_jmethod_id(jmid) == _new_methods->at(_matching_new_methods[j]), "should be replaced");
+      jmethodID mid = (_new_methods->at(_matching_new_methods[j]))->jmethod_id();
+      //assert(JNIHandles::resolve_non_null((jobject)mid) == new_method_h(), "must match!");
+    }
+  }
+}
+
+
+// Deoptimize all compiled code that depends on this class.
+//
+// If the can_redefine_classes capability is obtained in the onload
+// phase then the compiler has recorded all dependencies from startup.
+// In that case we need only deoptimize and throw away all compiled code
+// that depends on the class.
+//
+// If can_redefine_classes is obtained sometime after the onload
+// phase then the dependency information may be incomplete. In that case
+// the first call to RedefineClasses causes all compiled code to be
+// thrown away. As can_redefine_classes has been obtained then
+// all future compilations will record dependencies so second and
+// subsequent calls to RedefineClasses need only throw away code
+// that depends on the class.
+//
+void VM_EnhancedRedefineClasses::flush_dependent_code(instanceKlassHandle k_h, TRAPS) {
+  assert_locked_or_safepoint(Compile_lock);
+
+  // All dependencies have been recorded from startup or this is a second or
+  // subsequent use of RedefineClasses
+
+  // For now deopt all
+  // (tw) TODO: Improve the dependency system such that we can safely deopt only a subset of the methods
+  
+    CodeCache::mark_all_nmethods_for_deoptimization();
+
+    ResourceMark rm(THREAD);
+    DeoptimizationMarker dm;
+
+    // Deoptimize all activations depending on marked nmethods
+    Deoptimization::deoptimize_dependents();
+
+    // Make the dependent methods not entrant (in VM_Deoptimize they are made zombies)
+    CodeCache::make_marked_nmethods_not_entrant();
+
+    // From now on we know that the dependency information is complete
+    JvmtiExport::set_all_dependencies_are_recorded(true);
+  
+}
+
+void VM_EnhancedRedefineClasses::compute_added_deleted_matching_methods() {
+  Method* old_method;
+  Method* new_method;
+
+  _matching_old_methods = NEW_RESOURCE_ARRAY(int, _old_methods->length());
+  _matching_new_methods = NEW_RESOURCE_ARRAY(int, _old_methods->length());
+  _added_methods        = NEW_RESOURCE_ARRAY(int, _new_methods->length());
+  _deleted_methods      = NEW_RESOURCE_ARRAY(int, _old_methods->length());
+
+  _matching_methods_length = 0;
+  _deleted_methods_length  = 0;
+  _added_methods_length    = 0;
+
+  int nj = 0;
+  int oj = 0;
+  while (true) {
+    if (oj >= _old_methods->length()) {
+      if (nj >= _new_methods->length()) {
+        break; // we've looked at everything, done
+    }
+      // New method at the end
+      new_method = _new_methods->at(nj);
+      _added_methods[_added_methods_length++] = nj;
+      ++nj;
+    } else if (nj >= _new_methods->length()) {
+      // Old method, at the end, is deleted
+      old_method = _old_methods->at(oj);
+      _deleted_methods[_deleted_methods_length++] = oj;
+      ++oj;
+    } else {
+      old_method = _old_methods->at(oj);
+      new_method = _new_methods->at(nj);
+      if (old_method->name() == new_method->name()) {
+        if (old_method->signature() == new_method->signature()) {
+          _matching_old_methods[_matching_methods_length] = oj;//old_method;
+          _matching_new_methods[_matching_methods_length] = nj;//new_method;
+          _matching_methods_length++;
+          ++nj;
+          ++oj;
+        } else {
+          // added overloaded have already been moved to the end,
+          // so this is a deleted overloaded method
+          _deleted_methods[_deleted_methods_length++] = oj;//old_method;
+          ++oj;
+        }
+      } else { // names don't match
+        if (old_method->name()->fast_compare(new_method->name()) > 0) {
+          // new method
+          _added_methods[_added_methods_length++] = nj;//new_method;
+          ++nj;
+        } else {
+          // deleted method
+          _deleted_methods[_deleted_methods_length++] = oj;//old_method;
+          ++oj;
+        }
+      }
+    }
+  }
+  assert(_matching_methods_length + _deleted_methods_length == _old_methods->length(), "sanity");
+  assert(_matching_methods_length + _added_methods_length == _new_methods->length(), "sanity");
+  RC_TRACE(0x00008000, ("Matching methods = %d / deleted methods = %d / added methods = %d",
+                       _matching_methods_length, _deleted_methods_length, _added_methods_length));
+}
+
+
+
+// Install the redefinition of a class:
+//    - house keeping (flushing breakpoints and caches, deoptimizing
+//      dependent compiled code)
+//    - adjusting constant pool caches and vtables in other classes
+void VM_EnhancedRedefineClasses::redefine_single_class(instanceKlassHandle the_new_class, TRAPS) {
+
+  ResourceMark rm(THREAD);
+
+  assert(the_new_class->old_version() != NULL, "Must not be null");
+  assert(the_new_class->old_version()->new_version() == the_new_class(), "Must equal");
+
+  instanceKlassHandle the_old_class = instanceKlassHandle(THREAD, the_new_class->old_version());
+
+#ifndef JVMTI_KERNEL
+  // Remove all breakpoints in methods of this class
+  JvmtiBreakpoints& jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
+  jvmti_breakpoints.clearall_in_class_at_safepoint(the_old_class());
+#endif // !JVMTI_KERNEL
+
+  /* FIXME
+  if (the_old_class() == Universe::reflect_invoke_cache()->klass()) {
+    // We are redefining java.lang.reflect.Method. Method.invoke() is
+    // cached and users of the cache care about each active version of
+    // the method so we have to track this previous version.
+    // Do this before methods get switched
+    Universe::reflect_invoke_cache()->add_previous_version(
+      the_old_class->method_with_idnum(Universe::reflect_invoke_cache()->method_idnum()));
+  }*/
+
+  _old_methods = the_old_class->methods();
+  _new_methods = the_new_class->methods();
+  compute_added_deleted_matching_methods();
+
+  // track which methods are EMCP for add_previous_version() call below
+
+  // TODO: Check if we need the concept of EMCP?
+  // We need to mark methods as old!!
+  int emcp_method_count = check_methods_and_mark_as_obsolete();
+  update_jmethod_ids();
+
+  // TODO:
+  transfer_old_native_function_registrations(the_old_class);
+
+  // JSR-292 support
+
+  // Swap method handles
+  MemberNameTable* mnt = the_old_class->member_names();
+  assert(the_new_class->member_names() == NULL, "");
+  the_new_class->set_member_names(mnt);
+  the_old_class->set_member_names(NULL);
+
+  // FIXME: should we add field MemberName's in this list and process all of them here?
+//  if (mnt != NULL) {
+//    for (int i = 0; i < mnt->length(); i++) {
+//      oop mem_name = mnt->get_member_name(i);
+//      if (mem_name != NULL) {
+//        Method* method = (Method*) java_lang_invoke_MemberName::vmtarget(mem_name);
+//
+//        // Replace the method with matching one from the new class
+//        Method* new_method = the_new_class->find_method(method->name(), method->signature());
+//        java_lang_invoke_MemberName::set_vmtarget(mem_name, new_method);
+//      }
+//    }
+//  }
+
+#ifdef ASSERT
+
+//  Klass* systemLookup1 = SystemDictionary::resolve_or_null(the_old_class->name(), the_old_class->class_loader(), the_old_class->protection_domain(), THREAD);
+//  assert(systemLookup1 == the_new_class(), "New class must be in system dictionary!");
+
+  //JNIHandles::verify();
+
+//  Klass* systemLookup = SystemDictionary::resolve_or_null(the_old_class->name(), the_old_class->class_loader(), the_old_class->protection_domain(), THREAD);
+
+//  assert(systemLookup == the_new_class(), "New class must be in system dictionary!");
+  assert(the_new_class->old_version() != NULL, "Must not be null");
+  assert(the_new_class->old_version()->new_version() == the_new_class(), "Must equal");
+
+  for (int i=0; i<the_new_class->methods()->length(); i++) {
+    assert((the_new_class->methods()->at(i))->method_holder() == the_new_class(), "method holder must match!");
+  }
+
+  // FIXME:
+  //_old_methods->verify();
+  //_new_methods->verify();
+
+  the_new_class->vtable()->verify(tty);
+  the_old_class->vtable()->verify(tty);
+
+#endif
+
+  // increment the classRedefinedCount field in the_class and in any
+  // direct and indirect subclasses of the_class
+  increment_class_counter((InstanceKlass *)the_old_class(), THREAD);
+
+}
+
+
+int VM_EnhancedRedefineClasses::check_methods_and_mark_as_obsolete() {
+  RC_TRACE(0x00000100, ("Checking matching methods for EMCP"));
+  int emcp_method_count = 0;
+  int obsolete_count = 0;
+  int old_index = 0;
+  for (int j = 0; j < _matching_methods_length; ++j, ++old_index) {
+      Method* old_method = _old_methods->at(_matching_old_methods[j]);
+      Method* new_method = _new_methods->at(_matching_new_methods[j]);
+      Method* old_array_method;
+
+    // Maintain an old_index into the _old_methods array by skipping
+    // deleted methods
+    while ((old_array_method = _old_methods->at(old_index)) != old_method) {
+      ++old_index;
+    }
+
+    if (MethodComparator::methods_EMCP(old_method, new_method)) {
+      // The EMCP definition from JSR-163 requires the bytecodes to be
+      // the same with the exception of constant pool indices which may
+      // differ. However, the constants referred to by those indices
+      // must be the same.
+      //
+      // We use methods_EMCP() for comparison since constant pool
+      // merging can remove duplicate constant pool entries that were
+      // present in the old method and removed from the rewritten new
+      // method. A faster binary comparison function would consider the
+      // old and new methods to be different when they are actually
+      // EMCP.
+
+      // track which methods are EMCP for add_previous_version() call
+      emcp_method_count++;
+
+      // An EMCP method is _not_ obsolete. An obsolete method has a
+      // different jmethodID than the current method. An EMCP method
+      // has the same jmethodID as the current method. Having the
+      // same jmethodID for all EMCP versions of a method allows for
+      // a consistent view of the EMCP methods regardless of which
+      // EMCP method you happen to have in hand. For example, a
+      // breakpoint set in one EMCP method will work for all EMCP
+      // versions of the method including the current one.
+
+        old_method->set_new_version(new_method);
+        new_method->set_old_version(old_method);
+
+        RC_TRACE(0x00000100, ("Found EMCP method %s", old_method->name_and_sig_as_C_string()));
+
+        // Transfer breakpoints
+        InstanceKlass *ik = InstanceKlass::cast(old_method->method_holder());
+        for (BreakpointInfo* bp = ik->breakpoints(); bp != NULL; bp = bp->next()) {
+          RC_TRACE(0x00000100, ("Checking breakpoint: %d / %d",
+                               bp->match(old_method), bp->match(new_method)));
+          if (bp->match(old_method)) {
+            assert(bp->match(new_method), "if old method is method, then new method must match too");
+            RC_TRACE(0x00000100, ("Found a breakpoint in an old EMCP method"));
+            new_method->set_breakpoint(bp->bci());
+          }
+        }
+    } else {
+      // mark obsolete methods as such
+      old_method->set_is_obsolete();
+      obsolete_count++;
+
+      // With tracing we try not to "yack" too much. The position of
+      // this trace assumes there are fewer obsolete methods than
+      // EMCP methods.
+      RC_TRACE(0x00000100, ("mark %s(%s) as obsolete",
+                           old_method->name()->as_C_string(),
+                           old_method->signature()->as_C_string()));
+    }
+    old_method->set_is_old();
+  }
+  for (int i = 0; i < _deleted_methods_length; ++i) {
+      Method* old_method = _old_methods->at(_deleted_methods[i]);
+
+    //assert(old_method->vtable_index() < 0,
+    //  "cannot delete methods with vtable entries");;
+
+    // Mark all deleted methods as old and obsolete
+    old_method->set_is_old();
+    old_method->set_is_obsolete();
+    ++obsolete_count;
+    // With tracing we try not to "yack" too much. The position of
+    // this trace assumes there are fewer obsolete methods than
+    // EMCP methods.
+      RC_TRACE(0x00000100, ("mark deleted %s(%s) as obsolete",
+                           old_method->name()->as_C_string(),
+                           old_method->signature()->as_C_string()));
+    }
+    //assert((*emcp_method_count_p + obsolete_count) == _old_methods->length(), "sanity check");
+    RC_TRACE(0x00000100, ("EMCP_cnt=%d, obsolete_cnt=%d !",
+                         emcp_method_count, obsolete_count));
+    return emcp_method_count;
+}
+
+// Increment the classRedefinedCount field in the specific InstanceKlass
+// and in all direct and indirect subclasses.
+void VM_EnhancedRedefineClasses::increment_class_counter(Klass* klass, TRAPS) {
+  oop class_mirror = klass->java_mirror();
+  int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;
+  java_lang_Class::set_classRedefinedCount(class_mirror, new_count);
+  RC_TRACE(0x00000008, ("updated count for class=%s to %d", klass->external_name(), new_count));
+}
+
+#ifndef PRODUCT
+void VM_EnhancedRedefineClasses::check_class(Klass* k_oop, TRAPS) {
+  Klass *k = k_oop;
+  if (k->is_instance_klass()) {
+    HandleMark hm(THREAD);
+    InstanceKlass *ik = (InstanceKlass *) k;
+    assert(ik->is_newest_version(), "must be latest version in system dictionary");
+
+    if (ik->vtable_length() > 0) {
+      ResourceMark rm(THREAD);
+      assert(ik->vtable()->check_no_old_or_obsolete_entries(), "old method found");
+      ik->vtable()->verify(tty, true);
+    }
+  }
+}
+
+#endif
+
+static bool match_second(void* value, Pair<Klass*, Klass*> elem) {
+  return elem.second == value;
+}
+
+jvmtiError VM_EnhancedRedefineClasses::do_topological_class_sorting( const jvmtiClassDefinition *class_defs, int class_count, TRAPS) {
+  ResourceMark mark(THREAD);
+  GrowableArray<Pair<Klass*, Klass*> > links;
+
+  for (int i=0; i<class_count; i++) {
+
+    oop mirror = JNIHandles::resolve_non_null(class_defs[i].klass);
+    instanceKlassHandle the_class(THREAD, java_lang_Class::as_Klass(mirror));
+    Handle the_class_loader(THREAD, the_class->class_loader());
+    Handle protection_domain(THREAD, the_class->protection_domain());
+
+    ClassFileStream st((u1*) class_defs[i].class_bytes,
+      class_defs[i].class_byte_count, (char *)"__VM_EnhancedRedefineClasses__");
+   // ClassFileParser cfp(&st);
+
+
+
+    TempNewSymbol parsed_name;
+    GrowableArray<Symbol*>* super_symbols = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<Symbol*>(0, true);
+    KlassFactory::create_from_stream(&st, the_class->name(),
+                       the_class->class_loader_data(),
+                       protection_domain,
+                       the_class(), KlassHandle(),
+                       NULL,
+                       super_symbols,
+                       THREAD);
+
+    for (int j = 0; j < super_symbols->length(); j++) {
+      Symbol* sym = super_symbols->at(j);
+      Klass* super_klass = SystemDictionary::resolve_or_null(sym, the_class_loader, protection_domain, THREAD);
+      if (super_klass != NULL) {
+        instanceKlassHandle the_super_class(THREAD, super_klass);
+        if (_affected_klasses->contains(the_super_class)) {
+          links.append(Pair<Klass*, Klass*>(super_klass, the_class()));
+        }
+      }
+    }
+    delete super_symbols;
+
+    assert(the_class->check_redefinition_flag(Klass::MarkedAsAffected), "");
+    the_class->clear_redefinition_flag(Klass::MarkedAsAffected);
+  }
+
+  for (int i=0; i < _affected_klasses->length(); i++) {
+    instanceKlassHandle klass = _affected_klasses->at(i);
+
+    if (klass->check_redefinition_flag(Klass::MarkedAsAffected)) {
+      klass->clear_redefinition_flag(Klass::MarkedAsAffected);
+      Klass* superKlass = klass->super();
+      if (_affected_klasses->contains(superKlass)) {
+        links.append(Pair<Klass*, Klass*>(superKlass, klass()));
+      }
+
+      Array<Klass*>* superInterfaces = klass->local_interfaces();
+      for (int j=0; j<superInterfaces->length(); j++) {
+        Klass* interfaceKlass = superInterfaces->at(j);
+        if (_affected_klasses->contains(interfaceKlass)) {
+          links.append(Pair<Klass*, Klass*>(interfaceKlass, klass()));
+        }
+      }
+    }
+  }
+
+  for (int i = 0; i < _affected_klasses->length(); i++) {
+    int j;
+    for (j = i; j < _affected_klasses->length(); j++) {
+      // Search for node with no incoming edges
+      Klass* oop = _affected_klasses->at(j)();
+      int k = links.find(oop, match_second);
+      if (k == -1) break;
+    }
+    if (j == _affected_klasses->length()) {
+      return JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION;
+    }
+
+    // Remove all links from this node
+    Klass* oop = _affected_klasses->at(j)();
+    int k = 0;
+    while (k < links.length()) {
+      if (links.adr_at(k)->first == oop) {
+        links.delete_at(k);
+      } else {
+        k++;
+      }
+    }
+
+    // Swap node
+    instanceKlassHandle tmp = _affected_klasses->at(j);
+    _affected_klasses->at_put(j, _affected_klasses->at(i));
+    _affected_klasses->at_put(i, tmp);
+  }
+
+  return JVMTI_ERROR_NONE;
+}
+
+// This internal class transfers the native function registration from old methods
+// to new methods.  It is designed to handle both the simple case of unchanged
+// native methods and the complex cases of native method prefixes being added and/or
+// removed.
+// It expects only to be used during the VM_EnhancedRedefineClasses op (a safepoint).
+//
+// This class is used after the new methods have been installed in "the_class".
+//
+// So, for example, the following must be handled.  Where 'm' is a method and
+// a number followed by an underscore is a prefix.
+//
+//                                      Old Name    New Name
+// Simple transfer to new method        m       ->  m
+// Add prefix                           m       ->  1_m
+// Remove prefix                        1_m     ->  m
+// Simultaneous add of prefixes         m       ->  3_2_1_m
+// Simultaneous removal of prefixes     3_2_1_m ->  m
+// Simultaneous add and remove          1_m     ->  2_m
+// Same, caused by prefix removal only  3_2_1_m ->  3_2_m
+//
+class TransferNativeFunctionRegistration {
+ private:
+  instanceKlassHandle the_class;
+  int prefix_count;
+  char** prefixes;
+
+  // Recursively search the binary tree of possibly prefixed method names.
+  // Iteration could be used if all agents were well behaved. Full tree walk is
+  // more resilent to agents not cleaning up intermediate methods.
+  // Branch at each depth in the binary tree is:
+  //    (1) without the prefix.
+  //    (2) with the prefix.
+  // where 'prefix' is the prefix at that 'depth' (first prefix, second prefix,...)
+  Method* search_prefix_name_space(int depth, char* name_str, size_t name_len,
+                                     Symbol* signature) {
+      Symbol* name_symbol = SymbolTable::probe(name_str, (int)name_len);
+    if (name_symbol != NULL) {
+        Method* method = the_class()->new_version()->lookup_method(name_symbol, signature);
+      if (method != NULL) {
+        // Even if prefixed, intermediate methods must exist.
+        if (method->is_native()) {
+          // Wahoo, we found a (possibly prefixed) version of the method, return it.
+          return method;
+        }
+        if (depth < prefix_count) {
+          // Try applying further prefixes (other than this one).
+          method = search_prefix_name_space(depth+1, name_str, name_len, signature);
+          if (method != NULL) {
+            return method; // found
+          }
+
+          // Try adding this prefix to the method name and see if it matches
+          // another method name.
+          char* prefix = prefixes[depth];
+          size_t prefix_len = strlen(prefix);
+          size_t trial_len = name_len + prefix_len;
+          char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);
+          strcpy(trial_name_str, prefix);
+          strcat(trial_name_str, name_str);
+          method = search_prefix_name_space(depth+1, trial_name_str, trial_len,
+                                            signature);
+          if (method != NULL) {
+            // If found along this branch, it was prefixed, mark as such
+            method->set_is_prefixed_native();
+            return method; // found
+          }
+        }
+      }
+    }
+    return NULL;  // This whole branch bore nothing
+  }
+
+  // Return the method name with old prefixes stripped away.
+  char* method_name_without_prefixes(Method* method) {
+    Symbol* name = method->name();
+    char* name_str = name->as_utf8();
+
+    // Old prefixing may be defunct, strip prefixes, if any.
+    for (int i = prefix_count-1; i >= 0; i--) {
+      char* prefix = prefixes[i];
+      size_t prefix_len = strlen(prefix);
+      if (strncmp(prefix, name_str, prefix_len) == 0) {
+        name_str += prefix_len;
+      }
+    }
+    return name_str;
+  }
+
+  // Strip any prefixes off the old native method, then try to find a
+  // (possibly prefixed) new native that matches it.
+  Method* strip_and_search_for_new_native(Method* method) {
+    ResourceMark rm;
+    char* name_str = method_name_without_prefixes(method);
+    return search_prefix_name_space(0, name_str, strlen(name_str),
+                                    method->signature());
+  }
+
+ public:
+
+  // Construct a native method transfer processor for this class.
+  TransferNativeFunctionRegistration(instanceKlassHandle _the_class) {
+    assert(SafepointSynchronize::is_at_safepoint(), "sanity check");
+
+    the_class = _the_class;
+    prefixes = JvmtiExport::get_all_native_method_prefixes(&prefix_count);
+  }
+
+  // Attempt to transfer any of the old or deleted methods that are native
+  void transfer_registrations(instanceKlassHandle old_klass, int* old_methods, int methods_length) {
+    for (int j = 0; j < methods_length; j++) {
+      Method* old_method = old_klass->methods()->at(old_methods[j]);
+
+      if (old_method->is_native() && old_method->has_native_function()) {
+        Method* new_method = strip_and_search_for_new_native(old_method);
+        if (new_method != NULL) {
+          // Actually set the native function in the new method.
+          // Redefine does not send events (except CFLH), certainly not this
+          // behind the scenes re-registration.
+          new_method->set_native_function(old_method->native_function(),
+            !Method::native_bind_event_is_interesting);
+        }
+      }
+    }
+  }
+};
+
+// Don't lose the association between a native method and its JNI function.
+void VM_EnhancedRedefineClasses::transfer_old_native_function_registrations(instanceKlassHandle old_klass) {
+  TransferNativeFunctionRegistration transfer(old_klass);
+  transfer.transfer_registrations(old_klass, _deleted_methods, _deleted_methods_length);
+  transfer.transfer_registrations(old_klass, _matching_old_methods, _matching_methods_length);
+}
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/prims/jvmtiRedefineClasses2.hpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/vm/prims/jvmtiRedefineClasses2.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_VM_PRIMS_JVMTIENHANCEDREDEFINECLASSES_HPP
+#define SHARE_VM_PRIMS_JVMTIENHANCEDREDEFINECLASSES_HPP
+
+#include "jvmtifiles/jvmtiEnv.hpp"
+#include "memory/oopFactory.hpp"
+#include "memory/resourceArea.hpp"
+#include "oops/objArrayKlass.hpp"
+#include "oops/objArrayOop.hpp"
+#include "oops/fieldStreams.hpp"
+//#include "prims/jvmtiRedefineClassesTrace.hpp"
+//#include "gc_implementation/shared/vmGCOperations.hpp"
+#include "gc/shared/vmGCOperations.hpp"
+
+// New version that allows arbitrary changes to already loaded classes.
+class VM_EnhancedRedefineClasses: public VM_GC_Operation {
+ private:
+
+  // These static fields are needed by SystemDictionary::classes_do()
+  // facility and the adjust_cpool_cache_and_vtable() helper:
+  static Array<Method*>* _old_methods;
+  static Array<Method*>* _new_methods;
+  static int*            _matching_old_methods;
+  static int*            _matching_new_methods;
+  static int*            _deleted_methods;
+  static int*            _added_methods;
+  static int             _matching_methods_length;
+  static int             _deleted_methods_length;
+  static int             _added_methods_length;
+
+  static int             _revision_number;
+
+  static GrowableArray<instanceKlassHandle>* _affected_klasses;
+
+  // The instance fields are used to pass information from
+  // doit_prologue() to doit() and doit_epilogue().
+  jint                        _class_count;
+  const jvmtiClassDefinition *_class_defs;  // ptr to _class_count defs
+
+  // This operation is used by both RedefineClasses and
+  // RetransformClasses.  Indicate which.
+  JvmtiClassLoadKind          _class_load_kind;
+
+  GrowableArray<instanceKlassHandle>* _new_classes;
+  jvmtiError                  _result;
+  int                         _max_redefinition_flags;
+
+  // Performance measurement support. These timers do not cover all
+  // the work done for JVM/TI RedefineClasses() but they do cover
+  // the heavy lifting.
+  elapsedTimer _timer_total;
+  elapsedTimer _timer_prologue;
+  elapsedTimer _timer_class_linking;
+  elapsedTimer _timer_class_loading;
+  elapsedTimer _timer_prepare_redefinition;
+  elapsedTimer _timer_heap_iteration;
+  elapsedTimer _timer_redefinition;
+  elapsedTimer _timer_vm_op_epilogue;
+
+  jvmtiError find_sorted_affected_classes( );
+  jvmtiError find_class_bytes(instanceKlassHandle the_class, const unsigned char **class_bytes, jint *class_byte_count, jboolean *not_changed);
+  jvmtiError load_new_class_versions(TRAPS);
+
+  // Figure out which new methods match old methods in name and signature,
+  // which methods have been added, and which are no longer present
+  void compute_added_deleted_matching_methods();
+
+  // Change jmethodIDs to point to the new methods
+  void update_jmethod_ids();
+
+  static void add_affected_klasses( Klass* obj );
+
+  static jvmtiError do_topological_class_sorting(const jvmtiClassDefinition *class_definitions, int class_count, TRAPS);
+
+  // Install the redefinition of a class
+  void redefine_single_class(instanceKlassHandle the_new_class, TRAPS);
+
+  // Increment the classRedefinedCount field in the specific instanceKlass
+  // and in all direct and indirect subclasses.
+  void increment_class_counter(Klass* klass, TRAPS);
+
+
+  void flush_dependent_code(instanceKlassHandle k_h, TRAPS);
+
+  static void check_class(Klass* k_oop,/* oop initiating_loader,*/ TRAPS) PRODUCT_RETURN;
+
+  static void unpatch_bytecode(Method* method);
+
+#ifdef ASSERT
+  static void verify_classes(Klass* k_oop, oop initiating_loader, TRAPS);
+#endif
+
+  int calculate_redefinition_flags(instanceKlassHandle new_version);
+  void calculate_instance_update_information(Klass* new_version);
+  int check_methods_and_mark_as_obsolete();
+  static void mark_as_scavengable(nmethod* nm);
+
+  bool check_arguments();
+  jvmtiError check_arguments_error();
+
+  class ClearCpoolCacheAndUnpatch : public KlassClosure {
+    Thread* _thread;
+   public:
+    ClearCpoolCacheAndUnpatch(Thread* t) : _thread(t) {}
+    void do_klass(Klass* k);
+  };
+
+ public:
+  VM_EnhancedRedefineClasses(jint class_count, const jvmtiClassDefinition *class_defs, JvmtiClassLoadKind class_load_kind);
+
+  bool doit_prologue();
+  void doit();
+  void doit_epilogue();
+  void rollback();
+
+  jvmtiError check_exception() const;
+  VMOp_Type type() const                         { return VMOp_RedefineClasses; }
+  bool skip_operation() const                    { return false; }
+  bool allow_nested_vm_operations() const        { return true; }
+  jvmtiError check_error()                       { return _result;  }
+
+  // Modifiable test must be shared between IsModifiableClass query
+  // and redefine implementation
+  static bool is_modifiable_class(oop klass_mirror);
+
+  // Utility methods for transferring field access flags
+
+  static void transfer_special_access_flags(JavaFieldStream *from, JavaFieldStream *to);
+  static void transfer_special_access_flags(fieldDescriptor *from, fieldDescriptor *to);
+
+  void transfer_old_native_function_registrations(instanceKlassHandle the_class);
+
+  static void swap_marks(oop first, oop second);
+};
+
+#endif // SHARE_VM_PRIMS_JVMTIENHANCEDREDEFINECLASSES_HPP
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/runtime/arguments.cpp
--- a/src/share/vm/runtime/arguments.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/runtime/arguments.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -1841,6 +1841,10 @@
 
 void Arguments::select_gc_ergonomically() {
 #if INCLUDE_ALL_GCS
+    if (AllowEnhancedClassRedefinition) {
+        // (DCEVM) enforces serial GC
+         FLAG_SET_ERGO(bool, UseSerialGC, true);
+            }
   if (os::is_server_class_machine()) {
     if (!UseAutoGCSelectPolicy) {
        FLAG_SET_ERGO_IF_DEFAULT(bool, UseG1GC, true);
@@ -2424,6 +2428,15 @@
   if (UseConcMarkSweepGC)                i++;
   if (UseParallelGC || UseParallelOldGC) i++;
   if (UseG1GC)                           i++;
+  if (AllowEnhancedClassRedefinition) {
+        // (DCEVM) Must use serial GC. This limitation applies because the instance size changing GC modifications
+         // are only built into the mark and compact algorithm.
+         if (!UseSerialGC && i >= 1) {
+            jio_fprintf(defaultStream::error_stream(),
+                    "Must use the serial GC in the DCEVM\n");
+            return false;
+                    }
+          }
   if (i > 1) {
     jio_fprintf(defaultStream::error_stream(),
                 "Conflicting collector combinations in option list; "
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/runtime/globals.hpp
--- a/src/share/vm/runtime/globals.hpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/runtime/globals.hpp	Fri Dec 15 05:23:25 2017 -0500
@@ -697,6 +697,9 @@
           "A thread requesting compilation is not blocked during "          \
           "compilation")                                                    \
                                                                             \
+  product(intx, TraceRedefineClasses, 0,                                    \
+          "Trace level for JVMTI RedefineClasses")                          \
+                                                                            \
   product(bool, PrintVMQWaitTime, false,                                    \
           "Print out the waiting time in VM operation queue")               \
                                                                             \
@@ -1352,6 +1355,9 @@
   product(bool, VerifyMergedCPBytecodes, true,                              \
           "Verify bytecodes after RedefineClasses constant pool merging")   \
                                                                             \
+  product(bool, AllowEnhancedClassRedefinition, true,                       \
+          "Allow enhanced class redefinition beyond swapping method bodies")\
+                                                                            \
   develop(bool, TraceBytecodes, false,                                      \
           "Trace bytecode execution")                                       \
                                                                             \
diff -r 5be37d3ef648 -r bf6d41e48c32 src/share/vm/runtime/reflection.cpp
--- a/src/share/vm/runtime/reflection.cpp	Wed Sep 27 17:36:28 2017 -0700
+++ b/src/share/vm/runtime/reflection.cpp	Fri Dec 15 05:23:25 2017 -0500
@@ -645,6 +645,12 @@
                                      AccessFlags access,
                                      bool classloader_only,
                                      bool protected_restriction) {
+
+  // (DCEVM) Decide accessibility based on active version
+  if (current_class != NULL) {
+    current_class = current_class->active_version();
+  }
+
   // Verify that current_class can access a field of field_class, where that
   // field's access bits are "access".  We assume that we've already verified
   // that current_class can access field_class.
